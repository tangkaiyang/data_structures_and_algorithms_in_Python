
抽象数据类型的重要概念
Python面向对象的程序设计技术.可以看作是一种实现抽象数据类型的技术,但有所扩充

2.1抽象数据类型:Abstract Data Type,ADT,
ADT基本思想是抽象,或者说数据抽象(与函数定义实现的计算抽象或称过程抽象对应)
2.1.1 数据类型和数据构造
2.1.2 抽象数据类型的概念
把对象的使用与其具体实现隔离开
抽象数据单元:在编程中使用一种对象时,只需考虑应该如何使用,不需要(最好是根本不能)去关注和触及对象的内部表示.
抽象数据类型的基本想法:把数据定义为抽象的对象集合,只为他们定义可用的合法操作,并不暴露其内部实现的具体细节,
不论是其数据的表示还是操作的实现细节.
抽象数据类型提供的操作应该满足如下要求.一个数据类型的操作通常可用分为三类:
1)构造操作:基于一些已知信息,产生出这种类型的一个新对象
2)解析操作:从一个对象取得有用的信息,其结果反映了被操作对象的某方面特性,但结果并不是本类型的对象.
3)变动操作:修改被操作对象的内部状态
当然,一个抽象数据类型还应该有一个名字,用于代表这个类型
数据类型的变动性,表示该类型的对象在创建之后是否允许变化.
不变数据类型,该类型的对象称为不变对象/可变数据类型,其对象成为可变对象/简称为不变类型和可变类型
定义一个抽象数据类型时应该怎样思考问题,怎样描述抽象数据类型,描述中应该给出哪些信息
2.1.3 抽象数据类型的描述
一个简单的有理数抽象数据类型的描述:
ADT Rational:                           # 定义有理数的抽象数据类型
    Rational(int num, int den)          # 构造有理数num/den
    +(Rational r1, Rational r2)         # 求出表示r1+r2的有理数
    -(Rational r1, Rational r2)         # 求出表示r1-r2的有理数
    *(Rational r1, Rational r2)         # 求出表示r1*r2的有理数
    /(Rational r1, Rational r2)         # 求出表示r1/r2的有理数
    num(Rational r1)                    # 取得有理数r1的分子
    den(Rational r2)                    # 取得有理数r2的分母
ADT是一种思想,也是一种组织程序的技术,主要包括:
1)围绕着一类数据定义程序模块
2)模块的接口和实现分离.
3)在需要实现时,从所用的编程语言里选择一套合适的机制,采用合理的技术,实现这种ADT的功能,包括具体的数据表示和操作

2.2 Python的类
抽象数据类型的基本思想和描述技术在Python语言里的实现.
Python语言里没有直接的ADT定义,实现ADT可用采用很多不同的技术.
最自然的一种技术:利用class定义(类定义)实现抽象数据类型.
2.2.2 类定义的进阶
类定义的一类重要作用时支持创建抽象的数据类型.
约定:下划线开头的属性名(和函数名)都当作内部使用的名字,不应该在这个类之外使用.
Python对类定义里以两个下划线开头(但不以两个下划线结尾)的名字做了特殊处理,使得在类定义之外不能直接使用这个名字访问.
最大公约数gcd,分数化简
应该在哪里定义这个函数.
两种新情况:首先gcd的参数应该是两个整数,它们不属于被定义的有理数类型(?).此外,gcd的计算并不依赖任何有理数类的对象,
因此其参数表中似乎不应该以表示有理数的self作为第一个参数.但另一方面,这个gcd是为有理数类的实现而需要使用的一种
辅助功能,根据信息局部化的原则,局部使用的功能不应该定义为全局函数.
综合上述两种情况,gcd应该是在有理数类里定义的一个非实例方法.
Python把在类里定义的这种方法称为静态方法(与实例方法不同),描述时需要在函数定义的头部行之前
加修饰符@staticmethod.静态方法的参数表中不应该有self参数,在其他方面没有任何限制.
对于静态方法,可以从其定义所在类的名字出发通过圆点形式调用,也可以从该类的对象出发通过圆点形式调用.
本质上说,静态方法就是在类里面定义的普通函数,但是也是该类的局部函数.
还有一个问题:检查参数
实现运算符对应的特殊方法
整除运算符"//".
按照Python惯例,普通除法"/"的结果应是浮点数,对应方法名为__truediv__,
还需注意一个情况:算术运算符都要求另一个参数也是有理数对象.如果希望检查这个条件,可以在方法定义的开始加一个条件
语句,用内置谓语isinstance(another, Rational)检查.
比较运算符对应的特殊方法:
__eq__:=, __ne__:!=, __lt__:<, __le__:<=, __ge__:>=, __gt__: >
对象转换到字符串的方法:str:__str__

2.2.3 本书采用的ADT描述形式
本书后面章节将主要采用Python的面向对象技术和类结构定义各种数据结构类型,
后面使用的ADT描述将模仿Python类定义的形式,也认为ADT描述的是一个类型,因此:
# ADT的基本创建函数将以self为第一个参数,表示被创建的对象,其他参数表示为正确创建对象时需要提供的其他信息
# 在ADT描述中的每个操作也都以self作为第一个参数,表示被操作的对象
# 定义二元运算时也采用同样的形式,其参数表将包括self和另一个同类型对象,操作返回的是运算生成的结果对象
# 虽然Python函数定义的参数表里没有描述参数类型的机制,但为了提供更多信息,在下面写ADT定义时,有时还有采用写参数
类型的形式,用于说明操作对具体参数的类型要求.
这种方式描述的有理数对象ADT如下:
ADT Rational:                           # 定义有理数的抽象数据类型
    Rational(self, int, num, int den)   # 构造有理数num/den
    +(self, Rational r2)                # 求出本对象加r2的结果(有理数)
    -(self, Rational r2)                # 求出本对象减r2的结果(有理数)
    *(self, Rational r2)                # 求出本对象乘以r2的结果
    /(self, Rational r2)                # 求出本对象除以r2的结果
    num(self)                           # 取得本对象的分子
    den(self)                           # 取得本对象的分母
2.3 类的基本定义和使用
一个类定义确定了一个名字空间,位于类里面的定义都局部与这个类体,这些局部名字在该类之外不能直接看到,不会与外面的
名字冲突.在执行一个类定义时,将以该定义为作用域创建一个新的名字空间.类定义里的所有语句(包括方法定义)都在这个
局部名字空间里产生效果.这样创建的类名字空间将一直存在,除非明确删除(del).当一个类定义的执行完成时,Python解释器
创建相应的类对象,其中包装了该类里的所有定义,然后转回到原来的(也就是该类定义所在的)名字空间,在其中建立这个新的类对象
与类名字的约束.在此之后通过类名字就能引用相应的类对象了.
类里定义的变量和函数等成为这个类的属性.
类定义可以写在程序的任何地方.可以把类定义放在某个函数定义里,或者放在另一类定义里,效果是在那里建立一个局部的类
定义.但在实践中,人们通常总是把类定义写在模块最外层,这样定义的(类)类型在整个模块里都可以使用,而且允许其他模块里
通过import语句导入和使用
类对象及其说明
执行一个类定义将创建起一个类对象,这种对象主要支持两种操作:属性访问和实例化(即创建这个类的实例对象)
每个类对象都有一个默认存在的__doc__数据属性,其值是该类的文档串
在定义好一个类之后,可以通过实例化操作创建该类的实例对象.实例化采用函数调用的语法形式,最简单的情况就像是
调用一个无参函数,例如
    x = className()
假设className是一个已有定义的类.上面语句将创建className类的一个新实例(实例对象),并把该对象赋给变量x.如果
className类里没有定义初始化函数,这一简单调用创建的是该类的一个空对象,其中没有数据属性
2.3.2 实例对象:初始化和使用
创建类的实例对象时自动完成适当的初始化.
Python类中具有特殊名字__init__的方法自动完成初始化工作:
# 如果在一个类里定义了__init__方法,在创建这个类的实例时,Python解释器就会自动调用这个方法
# __init__方法的第一个参数(通常用self作为参数名)总表示当前正在创建的对象.方法体重可以通过属性赋值的方式
(形式为self.fname的赋值,fname是自己选定的属性名)为该对象定义属性并设定初始值
# __init__可以有更多形式参数.如果存在这种参数,在创建该类的实例对象时,就需要为(除第一个self之外的)形式参数
提供实际参数值,用表达式写在类名后面的实参表里.在创建实例对象时,这些实际参数将被送到__init__,使它可以基于这些实参对实例对象做特定的初始化
类实例(对象)的数据属性
对于已有的类实例对象,可以通过属性引用的方式访问其数据属性.在Python语言里,类实例的数据属性不需要专门声明,
只要给队形的属性赋值,就会自动建立这种属性(就像普通变量一样).每个实例对象是一个局部名字空间,其中包含该对象的
所有数据属性及其约束值,对象的全体数据属性的取值情况构成该对象的状态.如果建立的是空对象,它就有一个空的名字空间.
如果在类里定义了初始化函数,创建的实例对象就会包含该函数设置的属性.
由于上述情况,人们在定义类时,通常总是通过自动调用的__init__函数建立实例对象的初始状态,用类里定义的其他函数查看
或者修改实例对象的状态.实际上,Python允许再任意方法里给原本没有的(也就是说,初始化函数没建立的)属性赋值,
这种赋值将扩大该对象的名字空间.但在实际中这种做法并不多见.
一个实例对象是一个独立的数据体,可以像其他对象一样赋给变量作为约束值,或者传进函数处理,或者作为函数的结果返回等.
实例对象也可以作为其他实例对象的属性值(无论是同属一个类的实例对象,或不属于同一个类的实例对象),这种情况形成了更
复杂的对象结构.在复杂的程序里,这种情况很常见
方法的定义和使用
除数据属性外,类实例的另一类属性就是方法.
在一个类定义里按默认方式定义的函数,都可以作为这个类的实例对象的方法.但是,如果确实希望类里的一个函数能作为该类
实例的方法使用,这个函数至少需要一个表示其调用对象的形参,放在函数定义的参数表里的第一个位置.这个形参通常取名为
self(实际上可以用任何名字,用self作为参数名是Python社团的习惯做法).除了self之外,还可以根据需要为函数引入
更多形参.下面将类里的这种函数为(实例)方法函数.除了是在类里定义而且至少有一个形参外,方法函数并没有特殊之处,
从其他方面看他们就是一般的函数,Python关于函数的规定在这里都适用.
简单地说,如果类里定义了一个方法函数,这个类的实例对象就可以通过属性引用的方式调用这个函数.在用
x.method()的形式调用方法函数method时,对象x将被作为method的第一个实参,约束到方法函数的第一个形参self,其他实参
按Python有关函数调用的规定分别约束到method的其他形参,然后执行该函数的体代码
说得更准确些.如果在程序里通过某个类C的实例对象o,以属性引用的形式调用类C里定义的方法函数m,Python解释器就会
创建一个方法对象,把实例对象o和方法函数m约束在这个方法对象里.在(后面)执行这个方法对象时,o会被作为函数m的第一个
实参.在函数m的定义里通过形参self的属性访问,都实现为调用对象o的属性访问(取值或赋值)
一个具体例子(和写法)
# 假设在类C里定义了方法函数m,C.m就是一个函数,其值是普通的函数对象,就像采用其他方式定义的函数一样,例如
math.sin的值就是一个函数对象
# 假设变量p的值是类C的一个实例,表达式p.m的值就是基于这个实例和函数m建立的一个方法对象
# 使用方法对象的最常见方式是直接通过类实例做方法调用.例如,假设类C的方法函数m有三个形参,变量p的值是类C的实例,
从p出发调用m就应写成p.m(a, b)的形式,这里假设a和b是适合作为另两个参数的表达式
# 从上面的说明不难看到,方法调用p.m(...)实际上等价于函数调用C.m(p, ...).方法的其他参数可以通过调用表达式中的其他实参提供.
# 方法对象也是一种(类似函数的)对象,可以作为对象使用.例如,可以把方法对象赋给变量,或者作为实参传入函数,然后在
函数的其他地方作为函数去调用.在上面假设的情况下,程序里完全可以写成"q=p.m",而后可以在其他地方写调用
q(a, b),表示a和b作为实参调用这个方法
注意,方法对象和函数对象不同,它实际上包含了两个成分:一个是由类中的函数定义生成的函数对象,另一个是调用时
约束的(属于相应类的)一个实例对象.在这个方法对象最终执行时,其中的实例对象将作为函数的第一个实参
2.3.3 几点说明
对于类定义,方法定义等机制,有下面几点说明:
# 在执行了一个类定义,从而创建了相应的类对象之后,还可以通过属性赋值的方式为这个类(对象)增加新属性.
不仅可以为其增加数据属性,也可以增加函数属性.但是这是需要特别当心,如果新属性与已有函数属性同名,就会覆盖同名的属
性,这种情况又是可能是编程错误.人们一般采用特殊的命名规则避免这种错误.同样情况也可能出现在__init__方法里.
在初始化方法里赋值的属性与类定义中的方法同名时一种常见编程错误,应特别注意.举例说,假设Rational类定义了名字为num
的解析操作,如果在__init__函数里给self.num赋值,就会覆盖同名的方法定义.前面类定义里的数据属性名是_num,也避免了
这种名字冲突
# 如果需要在一个方法函数里调用同一个类里的其他方法函数,就需要明确地通过函数的第一个参数(self),以属性描述的方式
写方法调用.例如,在方法函数f里调用另个一方法函数g,应该写self.g(...)
# 从其他方面看,方法函数也就是定义在类里面的函数.其中也可以访问全局名字空间里的变量和函数,必要时也可以写global或
nonlocal声明
# Python提供了一个内置函数isinstance,专门用于检查类和对象的关系.表达式isinstance(obj, cls)检查对象obj是否为
类cls的实例,当obj的类是cls时得到True,否则得到False.实际上,isinstance可以用于检测任何对象与任何类型的关系.例
如检查一个变量或参数的值是否为int类型或float类型等.

静态方法和类方法
# 第一个类是前面介绍过的静态方法,定义形式是在def行前面加修饰符@staticmethod.
静态方法实际上就是普通函数,只是由于某种原因需要定义在类里面.静态方法的参数可以根据需要定义,不要特殊的self参数.
可以通过类名或者值为实例对象的变量,以属性引用的方式调用静态方法.例如,在前面Rational类里用Rational._gcd(...)的
形式调用静态方法_gcd,也可以写self._gcd(...).注意,静态方法没有self参数.这也意味着,无论采用上面哪种调用形式,
参数表里都必须为每个形参提供实参,这里没有自动使用的self参数.
# 类里定义的另一种方法称为类方法,定义形式是在def行前加修饰符@classmethod.这种方法必须有一个表示其调用类的参数,
习惯用cls作为参数名,还可以有任意多个其他参数.类方法也是类对象的属性,可以以属性访问的形式调用.在类方法执行时,调用
它的类将自动约束到方法的cls参数,可以通过这个参数访问该类的其他属性.
人们通常用类方法实现与本类的所有对象有关的操作

类定义的作用域规则
类定义作为Python语言里的一种重要定义结构,也是一种作用域单位.在类里定义的名字(标识符)具有局部作用域,只在这个类
里可用.如果需要在类定义之外使用,就采用基于类名字的属性引用方式.例如,下面定义是合法的
class C:
    a = 0
    b = a + 1
x = C.b
然而,在前面例子里可以看到一个情况:counter是类Countable的数据属性,但是在Countable类的两个方法里,都是通过类名和
圆点形式,采用属性引用的形式访问counter.实际上,在Python里必须这样做,在这方面,类作用域里的局部名字与函数作用域里
局部名字有不同的规定.
对于函数定义,其中局部名字的作用域自动延伸到内部嵌套的作用域.正因为这样,如果在一个函数f里定义局部函数g,在g的函数
体里可以直接使用f里有定义的变量,或使用在f里定义其他局部函数,除非这个名字在g里另有定义
对于类定义,情况则不是这样.在类C里定义的名字(C的数据属性或函数属性名),其作用域并不自动延伸到C内部嵌套的作用域.
因此,如果需要在类中的函数定义里引用这个类的属性,一定要采用基于类名的属性引用方式

私有变量
在面向对象的程序设计领域,人们通常把类实例对象里的数据属性称作实例变量.因为他们就像是定义在实例对象的名字空间里
的变量.
在一些面向对象语言里,允许把一些实例变量定义为私有变量,只允许在类定义的内部访问他们(也就是说,只允许在实例对象的
方法函数里访问),不允许在类定义之外使用.实际上,在类之外根本就看不到这种变量,这是一种信息隐藏机制.Python语言里没有
为定义私有变量提供专门的机制,没有办法说明某个属性只能在类的内部访问,只能通过编程约定和良好的编程习惯来保护实例
对象里的数据属性
在Python编程实践中,习惯约定是把以一个下划线开头的名字作为实例对象内部的东西,永远不从对象的外部去访问他们.无论
这样的名字指称的是(类或类实例的)数据成员,方法,还是类里定义的其他函数.也就是说,在编程中永远把具有这种名字的属性
看作类的实现细节.在前面的Rational类里,数据属性_num和_den,函数属性_gcd都是这种情况,在这个类定义之外都不应该使用.
另外,如果一个属性以两个下划线开头(但不以两个下划线结尾),在类之外采用属性访问方式直接写这个名字将无法找到他.
Python解释器会对类定义具有这种形式的名字做统一的改名.
此外,具有__add__形式(前后各有两个下划线)的名字有特殊的意义,除了前面介绍过的表示各种算术运算符,比较运算符的
特殊名字和__init__,__str__之外,还有一大批特殊名字.
实际上,在Python编程中,上述约定不仅仅针对类及其实例对象,也适用于模块等一切具有内部结构的对象

2.3.4 继承
基于类和对象的程序设计被称为面向对象的程序设计,在这里的基本工作包括三个方面:
定义程序里需要的类(也是定义新类型);创建这些类的(实例)对象;调用对象的方法完成计算工作,包括完成对象之间的信息交流等.
类定义的一种重要机制:继承.
继承的主要作用有两个:一个是可以基于已有的类定义新类,通过继承的方式复用已有类的功能,重复利用已有的代码(已有的类定义),
减少定义新类的工作量,简化新功能的开发,提高工作效率.
另一个作用实际上更重要,就是建立一组类(类型)之间的继承关系,利用这种关系有可能更好地组织和构造复杂的程序.

继承,基类和派生类
替换原理:一个类B的实例对象的上下文中可以使用其派生类C的实例对象.
所有的类根据继承关系形成了一种层次结构
issubclass