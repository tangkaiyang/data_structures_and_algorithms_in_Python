
抽象数据类型的重要概念
Python面向对象的程序设计技术.可以看作是一种实现抽象数据类型的技术,但有所扩充

2.1抽象数据类型:Abstract Data Type,ADT,
ADT基本思想是抽象,或者说数据抽象(与函数定义实现的计算抽象或称过程抽象对应)
2.1.1 数据类型和数据构造
2.1.2 抽象数据类型的概念
把对象的使用与其具体实现隔离开
抽象数据单元:在编程中使用一种对象时,只需考虑应该如何使用,不需要(最好是根本不能)去关注和触及对象的内部表示.
抽象数据类型的基本想法:把数据定义为抽象的对象集合,只为他们定义可用的合法操作,并不暴露其内部实现的具体细节,
不论是其数据的表示还是操作的实现细节.
抽象数据类型提供的操作应该满足如下要求.一个数据类型的操作通常可用分为三类:
1)构造操作:基于一些已知信息,产生出这种类型的一个新对象
2)解析操作:从一个对象取得有用的信息,其结果反映了被操作对象的某方面特性,但结果并不是本类型的对象.
3)变动操作:修改被操作对象的内部状态
当然,一个抽象数据类型还应该有一个名字,用于代表这个类型
数据类型的变动性,表示该类型的对象在创建之后是否允许变化.
不变数据类型,该类型的对象称为不变对象/可变数据类型,其对象成为可变对象/简称为不变类型和可变类型
定义一个抽象数据类型时应该怎样思考问题,怎样描述抽象数据类型,描述中应该给出哪些信息
2.1.3 抽象数据类型的描述
一个简单的有理数抽象数据类型的描述:
ADT Rational:                           # 定义有理数的抽象数据类型
    Rational(int num, int den)          # 构造有理数num/den
    +(Rational r1, Rational r2)         # 求出表示r1+r2的有理数
    -(Rational r1, Rational r2)         # 求出表示r1-r2的有理数
    *(Rational r1, Rational r2)         # 求出表示r1*r2的有理数
    /(Rational r1, Rational r2)         # 求出表示r1/r2的有理数
    num(Rational r1)                    # 取得有理数r1的分子
    den(Rational r2)                    # 取得有理数r2的分母
ADT是一种思想,也是一种组织程序的技术,主要包括:
1)围绕着一类数据定义程序模块
2)模块的接口和实现分离.
3)在需要实现时,从所用的编程语言里选择一套合适的机制,采用合理的技术,实现这种ADT的功能,包括具体的数据表示和操作

2.2 Python的类
抽象数据类型的基本思想和描述技术在Python语言里的实现.
Python语言里没有直接的ADT定义,实现ADT可用采用很多不同的技术.
最自然的一种技术:利用class定义(类定义)实现抽象数据类型.
2.2.2 类定义的进阶
类定义的一类重要作用时支持创建抽象的数据类型.
约定:下划线开头的属性名(和函数名)都当作内部使用的名字,不应该在这个类之外使用.
Python对类定义里以两个下划线开头(但不以两个下划线结尾)的名字做了特殊处理,使得在类定义之外不能直接使用这个名字访问.
最大公约数gcd,分数化简
应该在哪里定义这个函数.
两种新情况:首先gcd的参数应该是两个整数,它们不属于被定义的有理数类型(?).此外,gcd的计算并不依赖任何有理数类的对象,
因此其参数表中似乎不应该以表示有理数的self作为第一个参数.但另一方面,这个gcd是为有理数类的实现而需要使用的一种
辅助功能,根据信息局部化的原则,局部使用的功能不应该定义为全局函数.
综合上述两种情况,gcd应该是在有理数类里定义的一个非实例方法.
Python把在类里定义的这种方法称为静态方法(与实例方法不同),描述时需要在函数定义的头部行之前
加修饰符@staticmethod.静态方法的参数表中不应该有self参数,在其他方面没有任何限制.
对于静态方法,可以从其定义所在类的名字出发通过圆点形式调用,也可以从该类的对象出发通过圆点形式调用.
本质上说,静态方法就是在类里面定义的普通函数,但是也是该类的局部函数.
还有一个问题:检查参数
实现运算符对应的特殊方法
整除运算符"//".
按照Python惯例,普通除法"/"的结果应是浮点数,对应方法名为__truediv__,
还需注意一个情况:算术运算符都要求另一个参数也是有理数对象.如果希望检查这个条件,可以在方法定义的开始加一个条件
语句,用内置谓语isinstance(another, Rational)检查.
比较运算符对应的特殊方法:
__eq__:=, __ne__:!=, __lt__:<, __le__:<=, __ge__:>=, __gt__: >
对象转换到字符串的方法:str:__str__

2.2.3 本书采用的ADT描述形式
本书后面章节将主要采用Python的面向对象技术和类结构定义各种数据结构类型,
后面使用的ADT描述将模仿Python类定义的形式,也认为ADT描述的是一个类型,因此:
# ADT的基本创建函数将以self为第一个参数,表示被创建的对象,其他参数表示为正确创建对象时需要提供的其他信息
# 在ADT描述中的每个操作也都以self作为第一个参数,表示被操作的对象
# 定义二元运算时也采用同样的形式,其参数表将包括self和另一个同类型对象,操作返回的是运算生成的结果对象
# 虽然Python函数定义的参数表里没有描述参数类型的机制,但为了提供更多信息,在下面写ADT定义时,有时还有采用写参数
类型的形式,用于说明操作对具体参数的类型要求.
这种方式描述的有理数对象ADT如下:
ADT Rational:                           # 定义有理数的抽象数据类型
    Rational(self, int, num, int den)   # 构造有理数num/den
    +(self, Rational r2)                # 求出本对象加r2的结果(有理数)
    -(self, Rational r2)                # 求出本对象减r2的结果(有理数)
    *(self, Rational r2)                # 求出本对象乘以r2的结果
    /(self, Rational r2)                # 求出本对象除以r2的结果
    num(self)                           # 取得本对象的分子
    den(self)                           # 取得本对象的分母
2.3 类的基本定义和使用
一个类定义确定了一个名字空间,位于类里面的定义都局部与这个类体,这些局部名字在该类之外不能直接看到,不会与外面的
名字冲突.在执行一个类定义时,将以该定义为作用域创建一个新的名字空间.类定义里的所有语句(包括方法定义)都在这个
局部名字空间里产生效果.这样创建的类名字空间将一直存在,除非明确删除(del).当一个类定义的执行完成时,Python解释器
创建相应的类对象,其中包装了该类里的所有定义,然后转回到原来的(也就是该类定义所在的)名字空间,在其中建立这个新的类对象
与类名字的约束.在此之后通过类名字就能引用相应的类对象了.
类里定义的变量和函数等成为这个类的属性.
类定义可以写在程序的任何地方.可以把类定义放在某个函数定义里,或者放在另一类定义里,效果是在那里建立一个局部的类
定义.但在实践中,人们通常总是把类定义写在模块最外层,这样定义的(类)类型在整个模块里都可以使用,而且允许其他模块里
通过import语句导入和使用
类对象及其说明
执行一个类定义将创建起一个类对象,这种对象主要支持两种操作:属性访问和实例化(即创建这个类的实例对象)
每个类对象都有一个默认存在的__doc__数据属性,其值是该类的文档串
在定义好一个类之后,可以通过实例化操作创建该类的实例对象.实例化采用函数调用的语法形式,最简单的情况就像是
调用一个无参函数,例如
    x = className()
假设className是一个已有定义的类.上面语句将创建className类的一个新实例(实例对象),并把该对象赋给变量x.如果
className类里没有定义初始化函数,这一简单调用创建的是该类的一个空对象,其中没有数据属性
2.3.2 实例对象:初始化和使用
创建类的实例对象时自动完成适当的初始化.
Python类中具有特殊名字__init__的方法自动完成初始化工作:
# 如果在一个类里定义了__init__方法,在创建这个类的实例时,Python解释器就会自动调用这个方法
# __init__方法的第一个参数(通常用self作为参数名)总表示当前正在创建的对象.方法体重可以通过属性赋值的方式
(形式为self.fname的赋值,fname是自己选定的属性名)为该对象定义属性并设定初始值
# __init__可以有更多形式参数.如果存在这种参数,在创建该类的实例对象时,就需要为(除第一个self之外的)形式参数
提供实际参数值,用表达式写在类名后面的实参表里.在创建实例对象时,这些实际参数将被送到__init__,使它可以基于这些实参对实例对象做特定的初始化
类实例(对象)的数据属性
对于已有的类实例对象,可以通过属性引用的方式访问其数据属性.在Python语言里,类实例的数据属性不需要专门声明,
只要给队形的属性赋值,就会自动建立这种属性(就像普通变量一样).每个实例对象是一个局部名字空间,其中包含该对象的
所有数据属性及其约束值,对象的全体数据属性的取值情况构成该对象的状态.如果建立的是空对象,它就有一个空的名字空间.
如果在类里定义了初始化函数,创建的实例对象就会包含该函数设置的属性.
由于上述情况,人们在定义类时,通常总是通过自动调用的__init__函数建立实例对象的初始状态,用类里定义的其他函数查看
或者修改实例对象的状态.实际上,Python允许再任意方法里给原本没有的(也就是说,初始化函数没建立的)属性赋值,
这种赋值将扩大该对象的名字空间.但在实际中这种做法并不多见.
一个实例对象是一个独立的数据体,可以像其他对象一样赋给变量作为约束值,或者传进函数处理,或者作为函数的结果返回等.
实例对象也可以作为其他实例对象的属性值(无论是同属一个类的实例对象,或不属于同一个类的实例对象),这种情况形成了更
复杂的对象结构.在复杂的程序里,这种情况很常见
方法的定义和使用
除数据属性外,类实例的另一类属性就是方法.
在一个类定义里按默认方式定义的函数,都可以作为这个类的实例对象的方法.但是,如果确实希望类里的一个函数能作为该类
实例的方法使用,这个函数至少需要一个表示其调用对象的形参,放在函数定义的参数表里的第一个位置.这个形参通常取名为
self(实际上可以用任何名字,用self作为参数名是Python社团的习惯做法).除了self之外,还可以根据需要为函数引入
更多形参.下面将类里的这种函数为(实例)方法函数.除了是在类里定义而且至少有一个形参外,方法函数并没有特殊之处,
从其他方面看他们就是一般的函数,Python关于函数的规定在这里都适用.
简单地说,如果类里定义了一个方法函数,这个类的实例对象就可以通过属性引用的方式调用这个函数.在用
x.method()的形式调用方法函数method时,对象x将被作为method的第一个实参,约束到方法函数的第一个形参self,其他实参
按Python有关函数调用的规定分别约束到method的其他形参,然后执行该函数的体代码
说得更准确些.如果在程序里通过某个类C的实例对象o,以属性引用的形式调用类C里定义的方法函数m,Python解释器就会
创建一个方法对象,把实例对象o和方法函数m约束在这个方法对象里.在(后面)执行这个方法对象时,o会被作为函数m的第一个
实参.在函数m的定义里通过形参self的属性访问,都实现为调用对象o的属性访问(取值或赋值)
一个具体例子(和写法)
# 假设在类C里定义了方法函数m,C.m就是一个函数,其值是普通的函数对象,就像采用其他方式定义的函数一样,例如
math.sin的值就是一个函数对象
# 假设变量p的值是类C的一个实例,表达式p.m的值就是基于这个实例和函数m建立的一个方法对象
# 使用方法对象的最常见方式是直接通过类实例做方法调用.例如,假设类C的方法函数m有三个形参,变量p的值是类C的实例,
从p出发调用m就应写成p.m(a, b)的形式,这里假设a和b是适合作为另两个参数的表达式
# 从上面的说明不难看到,方法调用p.m(...)实际上等价于函数调用C.m(p, ...).方法的其他参数可以通过调用表达式中的其他实参提供.
# 方法对象也是一种(类似函数的)对象,可以作为对象使用.例如,可以把方法对象赋给变量,或者作为实参传入函数,然后在
函数的其他地方作为函数去调用.在上面假设的情况下,程序里完全可以写成"q=p.m",而后可以在其他地方写调用
q(a, b),表示a和b作为实参调用这个方法
注意,方法对象和函数对象不同,它实际上包含了两个成分:一个是由类中的函数定义生成的函数对象,另一个是调用时
约束的(属于相应类的)一个实例对象.在这个方法对象最终执行时,其中的实例对象将作为函数的第一个实参
2.3.3 几点说明
对于类定义,方法定义等机制,有下面几点说明:
# 在执行了一个类定义,从而创建了相应的类对象之后,还可以通过属性赋值的方式为这个类(对象)增加新属性.
不仅可以为其增加数据属性,也可以增加函数属性.但是这是需要特别当心,如果新属性与已有函数属性同名,就会覆盖同名的属
性,这种情况又是可能是编程错误.人们一般采用特殊的命名规则避免这种错误.同样情况也可能出现在__init__方法里.
在初始化方法里赋值的属性与类定义中的方法同名时一种常见编程错误,应特别注意.举例说,假设Rational类定义了名字为num
的解析操作,如果在__init__函数里给self.num赋值,就会覆盖同名的方法定义.前面类定义里的数据属性名是_num,也避免了
这种名字冲突
# 如果需要在一个方法函数里调用同一个类里的其他方法函数,就需要明确地通过函数的第一个参数(self),以属性描述的方式
写方法调用.例如,在方法函数f里调用另个一方法函数g,应该写self.g(...)
# 从其他方面看,方法函数也就是定义在类里面的函数.其中也可以访问全局名字空间里的变量和函数,必要时也可以写global或
nonlocal声明
# Python提供了一个内置函数isinstance,专门用于检查类和对象的关系.表达式isinstance(obj, cls)检查对象obj是否为
类cls的实例,当obj的类是cls时得到True,否则得到False.实际上,isinstance可以用于检测任何对象与任何类型的关系.例
如检查一个变量或参数的值是否为int类型或float类型等.

静态方法和类方法
# 第一个类是前面介绍过的静态方法,定义形式是在def行前面加修饰符@staticmethod.
静态方法实际上就是普通函数,只是由于某种原因需要定义在类里面.静态方法的参数可以根据需要定义,不要特殊的self参数.
可以通过类名或者值为实例对象的变量,以属性引用的方式调用静态方法.例如,在前面Rational类里用Rational._gcd(...)的
形式调用静态方法_gcd,也可以写self._gcd(...).注意,静态方法没有self参数.这也意味着,无论采用上面哪种调用形式,
参数表里都必须为每个形参提供实参,这里没有自动使用的self参数.
# 类里定义的另一种方法称为类方法,定义形式是在def行前加修饰符@classmethod.这种方法必须有一个表示其调用类的参数,
习惯用cls作为参数名,还可以有任意多个其他参数.类方法也是类对象的属性,可以以属性访问的形式调用.在类方法执行时,调用
它的类将自动约束到方法的cls参数,可以通过这个参数访问该类的其他属性.
人们通常用类方法实现与本类的所有对象有关的操作

类定义的作用域规则
类定义作为Python语言里的一种重要定义结构,也是一种作用域单位.在类里定义的名字(标识符)具有局部作用域,只在这个类
里可用.如果需要在类定义之外使用,就采用基于类名字的属性引用方式.例如,下面定义是合法的
class C:
    a = 0
    b = a + 1
x = C.b
然而,在前面例子里可以看到一个情况:counter是类Countable的数据属性,但是在Countable类的两个方法里,都是通过类名和
圆点形式,采用属性引用的形式访问counter.实际上,在Python里必须这样做,在这方面,类作用域里的局部名字与函数作用域里
局部名字有不同的规定.
对于函数定义,其中局部名字的作用域自动延伸到内部嵌套的作用域.正因为这样,如果在一个函数f里定义局部函数g,在g的函数
体里可以直接使用f里有定义的变量,或使用在f里定义其他局部函数,除非这个名字在g里另有定义
对于类定义,情况则不是这样.在类C里定义的名字(C的数据属性或函数属性名),其作用域并不自动延伸到C内部嵌套的作用域.
因此,如果需要在类中的函数定义里引用这个类的属性,一定要采用基于类名的属性引用方式

私有变量
在面向对象的程序设计领域,人们通常把类实例对象里的数据属性称作实例变量.因为他们就像是定义在实例对象的名字空间里
的变量.
在一些面向对象语言里,允许把一些实例变量定义为私有变量,只允许在类定义的内部访问他们(也就是说,只允许在实例对象的
方法函数里访问),不允许在类定义之外使用.实际上,在类之外根本就看不到这种变量,这是一种信息隐藏机制.Python语言里没有
为定义私有变量提供专门的机制,没有办法说明某个属性只能在类的内部访问,只能通过编程约定和良好的编程习惯来保护实例
对象里的数据属性
在Python编程实践中,习惯约定是把以一个下划线开头的名字作为实例对象内部的东西,永远不从对象的外部去访问他们.无论
这样的名字指称的是(类或类实例的)数据成员,方法,还是类里定义的其他函数.也就是说,在编程中永远把具有这种名字的属性
看作类的实现细节.在前面的Rational类里,数据属性_num和_den,函数属性_gcd都是这种情况,在这个类定义之外都不应该使用.
另外,如果一个属性以两个下划线开头(但不以两个下划线结尾),在类之外采用属性访问方式直接写这个名字将无法找到他.
Python解释器会对类定义具有这种形式的名字做统一的改名.
此外,具有__add__形式(前后各有两个下划线)的名字有特殊的意义,除了前面介绍过的表示各种算术运算符,比较运算符的
特殊名字和__init__,__str__之外,还有一大批特殊名字.
实际上,在Python编程中,上述约定不仅仅针对类及其实例对象,也适用于模块等一切具有内部结构的对象

2.3.4 继承
基于类和对象的程序设计被称为面向对象的程序设计,在这里的基本工作包括三个方面:
定义程序里需要的类(也是定义新类型);创建这些类的(实例)对象;调用对象的方法完成计算工作,包括完成对象之间的信息交流等.
类定义的一种重要机制:继承.
继承的主要作用有两个:一个是可以基于已有的类定义新类,通过继承的方式复用已有类的功能,重复利用已有的代码(已有的类定义),
减少定义新类的工作量,简化新功能的开发,提高工作效率.
另一个作用实际上更重要,就是建立一组类(类型)之间的继承关系,利用这种关系有可能更好地组织和构造复杂的程序.

继承,基类和派生类
替换原理:一个类B的实例对象的上下文中可以使用其派生类C的实例对象.
所有的类根据继承关系形成了一种层次结构
issubclass
派生类常需要重新定义__init__函数,完成该类实例的初始化.常见情况是要求派生类的对象可以
作为基类的对象,用在要求基类对象的环境中.在使用这中对象时,可能调用派生类自己定义的方法,
也可能调用由基类继承的方法.因此,在这种派生类的实例对象里就应该包含基类实例的所有数据属性,
在创建派生类的对象时,就需要对基类对象的所有数据属性进行初始化.
完成这一工作的常见方式是调用基类的__init__方法,利用它为正创建的实例里那些在基类实例中
也有的数据属性设置初值.

方法查找:
如果从一个派生类的实例对象出发去调用方法,Python解释器需要确定应该调用哪个函数(在哪个类里定义的函数).
查找过程从实例对象所属的类开始,如果在这里找到,就采用相应的函数定义;如果没找到就到这个类
的基类里找.这个过程沿着继承关系继续进行,在某个类里找到所需要的函数后使用它.如果查找过程
进行到已经没有可用的基类,最终也没找到所属函数属性,那就是属性无定义,Python解释器将会报告
AttributeError异常.Python解释器处理派生类的定义时,将在构造出的类对象里记录其基类的信息,
以支持使用这个类(及其对象)时的属性查找.
定义派生类时可用覆盖基类里已有的函数定义(重新定义一个同名函数).
假设在某个实例对象调用的一个方法f里调用了另一个方法g,而且后一方法也是基于这个实例对象
调用的(通过self.g(...)).在这种情况下,查找方法g的过程就是只与这个实例对象(的类型)有关,
与前以方法f是在哪个类里定义的情况无关
# code showing dynamic binding
class B:
    def f(self):
        self.g()
    def g(self):
        print('B.g called.')
class C(B):
    def g(self):
        print('C.g called.')
c = C()
c.f()
C.g called.
基于方法调用时self所表示的那个实例对象的类型去确定应该调用哪个g,这种方式称为动态约束
静态约束(静态绑定)
程序设计领域,这种通过动态约束确定调用关系的函数称为虚函数

标准函数super()
Python提供了一个内置函数super,把它用在派生类的方法定义里,就是要求从这个类的直接
基类开始做属性检索(而不是从这个类本身开始查找).采用super函数而不是直接写具体基类的
名字,产生的查找过程更加灵活.如果直接写基类的名字,无论在什么情况下执行,总是调用
该基类的方法,而如果写super(),Python解释器将根据当前类的情况去找到相应的基类,自动确定
究竟应该使用哪个基类的属性

2.4 Python异常
Python异常与类的关系,语言内建的异常类层次结构,以及Python语言如何利用面向对象的观点
组织异常处理过程.编程时有时需要自己定义异常(类型),如果需要这一做,就应该选一个系统异常类,从它派生
2.4.1 异常类和自定义异常
异常是Python语言中的一套特殊的控制机制,主要用于支持错误的检查和处理,也可以用于实现
特殊的控制转移.如果程序执行中发生异常,无论是解释器发现的异常情况(例如除零或类型错误等),
还是通过raise语句引发的异常,正常执行控制流立刻终止,解释器转入异常处理模式,查找能处理
所发生异常的处理器.如果找不到相应的异常处理器,在交互解释环境下,系统将在环境中输出错误信息,
结束当前执行并回到系统的交互状态,等待下一输入.在直接执行方式下,当前程序直接终止.
程序运行中发生的每个异常都有特定的名字,如ValueError,TypeError,ZeroDivisionError等
解释器根据发生的异常去查找处理器.Python里处理异常的结果是try语句.每个try语句可用带有多个except子句
这种子句就是异常处理器,子句头部用一个表达式描述它捕捉和处理的异常
实际上,Python的异常都是类(class),运行中产生异常就是生成相应类的实例对象,异常处理机制
完全基于面向对象的概念和性质.全体内部异常类构成了一个树形结构,所有异常类的基类是
BaseException,其主要的子类是Exception,内置异常类都是这个类的直接或间接派生类.
如果用户需要定义异常,就应该从系统异常类中选择一个合适的异常,从它派生出自己的异常类.
如:
    class RationalError(ValueError):
        pass
如果运行中发生了异常,查找相应处理器的工作由解释器完成,这里的工作方式也基于对象和类的关系.
在一个except子句头部可用列出一个或多个异常名(一般说,是表示异常类的表达式),列出多个
异常名时需要采用括号括起的元组形式.列在except子句头部的异常名表示异常处理器准备捕捉和
处理的异常.
运行中发生的异常与处理器的匹配按面向对象的方式处理.假设运行中发生的异常是e,如果一个
异常处理器头部列有异常名E,且isinstance(e, E)为真,那么这个处理器就能捕捉并处理异常e.

2.4.2 异常的传播和捕捉
运行中的异常可能发生在模块层面的语句的执行中,更多情况是发生在某个函数的执行中.假设在
函数f的执行中发生异常e,当前执行立即中断,解释器传入异常处理模式,设法找到处理e的处理器.
查找过程如下:
# 首先在发生异常的函数体里查找处理器:
# # 如果发生异常的语句位于一个try语句体里,首先顺序检查这个try语句后面的各except子句,
检查是否存在能处理e的处理器
# # 如果发生异常的try语句的所有异常处理器都不能处理e,解释器转去查看包围着该try语句的外围
try语句(如果存在),检查是否存在能与e匹配的异常处理器.这个查找过程将在e发生的函数f里逐层进行
# # 如果e不能在函数f里处理,f的执行异常终止,e在函数f这次执行的调用点重新引发,导致又一轮
处理器查找工作.查找规则与上面一样.
# 如果上面查找过程在某一步找到了与e匹配的处理器,解释器就转去执行该except子句的体(异常处理器代码)
执行完这段代码后,解释器回到正常执行模式,从该异常处理器所在的try语句之后继续执行
# 上述查找过程可能导致函数一层层以异常方式退出,有可能一直退到当前模块的最上层也没有
找到与之匹配的处理器:
# # 如果程序是在解释器的交互方式下执行,Python解释器终止该模块执行并回到交互状态,
输出错误信息后等待用户的下一个命令
# # 如果程序是自主执行(或称按批处理方式执行),该程序立即终止.
在异常处理过程中还可能出现一些情况.例如,正在执行处理器代码时又发生了新异常;或者处理中遇到某些特殊情况,需要引发新的异常.
2.4.3 内置的标准异常类
Python语言定义了一套标准异常类,都是BaseException的派生类,
其最重要子类是Exception,标准异常类都是Exception的直接或间接派生类.

2.5 类定义实例:学校人事管理系统中的类:
基本人员的ADT设计
ADT　Person:                         # 定义任意抽象数据类型
    Person(self, str name, str sex, tuple birthday,  strident)  # 构造人员对象
    id(self)                        # 取得该人员记录中的人员编号
    name(self)                      # 取得该人员记录中的姓名
    sex(self)                       # 取得该人员记录中的性别
    birthday(self)                  # 取得该人员记录中的出生年月日
    age(self)                       # 取得该人员的年龄
    set_name(self, str name)        # 修改任意性名
    <(self, Person another)         # 基于任意编号比较两个记录
    detail(self)                    # 给出任意记录里保存的数据详情
学生ADT的设计
ADT Student(Person):                # 定义学生ADT
    Student(self, str name, str sex, tuple birthday, str department) # 构造学生对象
    department(self)                # 取得学生所属院系
    en_year(self)                   # 取得学生入学年度
    scores(self)                    # 取得学生的成绩单
    set_course(self, str course_name) # 设置选课
    set_score(self, str course_name, int score) # 设置课程成绩
教职工ADT的设计
ADT Staff(Person):                  # 定义教职工ADT
    Staff(self, str name, str sex, tuple birthday, tuple entry_date) # 构造教职工对象
    department(self)                # 取得教职工所属院系
    salary(self)                    # 取得教职工的工资额
    entry_date(self)                # 取得教职工的入职时间
    position(self)                  # 取得教职工的职位
    set_salary(self, int amount)    # 设置工资额
2.5.2 人事记录类的实现
定义异常类:
class PersonTypeError(TypeError):
    pass
class PersonValueError(ValueError):
    pass
公共人员类的实现
Person:
数据属性_num,每当创建这个类的对象就将其值加一
学生类的实现:
Student
1)Student对象也是Person对象,调用Person类的初始化函数,建立起表示Person对象的那些数据属性
2)Student类实现一种学号生成方式.计数变量,每次生成学号时将其加一.Student内部数据,不属于任何Student实例对象,
因此应该用类的数据属性表示.
3)学号生成函数只在Student类的内部使用,但不依赖于Student的具体实例,然而这个函数并不是独立的,它依赖于Student类中的
数据属性,应该定义为类方法,而不是静态方法
并不是每个派生类的覆盖方法都需要重复基类方法的工作,是否调用基类被覆盖的方法,应根据需要确定.如果需要,必须通过基类名去调用或super函数
教职工类的实现
Staff
为教职工对象实现一个职工号生成函数,同样定义为类方法,

本节通过几个大学人事信息类的定义,总结了利用Python面向对象的继承机制,以及在已有类的基础上定义派生类时可能遇到的
各种问题,展示了Python面向对象编程的许多机制.
在上面的类定义里,还介绍了类的数据属性和类方法的使用.
在面向对象编程领域,定义派生类主要又两种用途:
1)定义基类对象中的一类特殊个体,他们具有与基类对象类似的行为,可以作为基类对象使用(替换原理),但通常还有一些自己的特殊
功能.为满足这种需求,从基类派生将能直接共享基类定义的操作,通过调用基类的初始化方法,建立派生类对象中与基类对象
相同的部分.派生类对象继承基类的方法属性,可用用重新定义的方式覆盖原有方法,也可以定义新方法.
2)只是为了宠用基类已有的功能,而将一个类定义为派生类.实际中有时也有这种需要,主要是为了代码的重用,这也是面向
对象中继承机制的一类用途
在定义一个类时,有时需要保存一些与整个类有关但并不特定与具体实例对象的信息,或者需要一些与整个类有关的功能.
这些就需要通过类的数据属性和类方法实现.类的数据属性通过类层面的赋值语句定义,类方法需要特殊前缀@classmethod描述.
基类和派生类是相对的.

本章总结
数据的抽象和计算过程的抽象
建立数据抽象为目标的抽象数据类型的思想
抽象数据类型的基本思想是抽象定义与数据表示和数据操作的实现分离.
定义抽象数据类型,首先要描述好这一类型的对象与外界的接口,通过一组操作(函数)描述.这样的接口定义在程序中划出了一条
清晰的分界:一边是抽象数据类型的实现,可用采用适合具体需要的任何技术;另一边是使用这个抽象数据类型的其他程序部分,
它们只需要相对于给定的操作接口定义,完全不必考虑有关功能是如何实现的.这种分离能很好地支持程序地模块化组织,是
分解和实现大型复杂系统地最重要基础技术
