文字处理是最重要的一类计算机应用.另一方面,各种计算机应用系统都需要与人交互,因此或多或少都需要处理文字信息.最基本
的文字处理是文本处理,处理对象是结构简单的语言文本,即是某种(或某些)自然语言中的基本文字符号构成的序列.在计算机
领域中,这样的基本文字符号称为字符,符号的序列称为字符串

字符集,字符串和字符串操作
讨论字符串及其数据结构实现,以及字符串处理,首先需要有一个确定的字符集.这里把字符作为一个抽象概念,字符集就是有穷
的一组字符构成的集合.在实际工作中,人们经常考虑的是计算机领域广泛使用的某种标准字符集,如ASCII字符集或者Unicode字符集.
实际上,完全可以用任意一个数据元素集合作为字符集.
基于字符串处理的需要,要求字符集上有一种确定的序关系,称为字符序,
字符串(简称串)可以看作一类特殊的线性表,表中元素取自选定的字符集.从这个角度看,字符串数据结构似乎就是一类特殊的
线性表,但实际上不尽然,因为字符串操作有其特点,而且其中许多操作并不是常见的线性操作.
对于线性表,人们经常考虑的是元素与表的关系,元素的插入和删除.而在考虑字符串时,人们关注的操作不同于一般线性表,
经常需要把字符串作为一个整体使用和处理,考虑许多以整个串为对象的操作.
字符串相关概念
# 字符串的长度:一个字符串中字符的个数称为该串的长度
# 字符在字符串里的位置:
# 字符串相等
# 字典序:字典序时字符串上的一种序关系,基于字符序定义.
从左向右看两个串中下标相同的各对字符,遇到的第一对不同字符的字符序决定了这两个字符串的顺序;
另外,如果两个串中相同下标的各对字符都相同,但其中一个串较短,那么就认为它较小,排在前面
# 字符串拼接
# 子串关系:
# 前缀和后缀时两种特殊字串
# 其他有用的串运算:串s的n次幂

字符串抽象数据类型
Python中将字符串定义为不可变类型
ADT String:
    String(self,sseq)       # 基于字符序列sseq建立一个字符串
    is_empty(self)          # 判断本字符串是否空串
    len(self)               # 取得字符串的长度
    char(self,index)        # 取得字符串中位置index的字符
    substr(self,a,b)        # 取得字符串中[a:b]的字串,左闭右开取键
    match(self,string)      # 查找串string在本字符串中第一个出现的位置
    concat(self,string)     # 做出本字符串与另一字符串string的拼接串
    subst(self,str1,str2)   # 做出将本字符串里的子串str1都替换为str2的结果串
最后两个操作可以实现为变动操作,实际修改本字符串;也可以实现为非变动操作,操作中生成满足要求的另一个字符串
子串检索操作(也称子串匹配)是字符串的核心操作

字符串的实现
字符串是字符的线性序列,可以采用线性表的各种实现技术实现,用顺序表或链接表的形式表示.
考虑字符串的表示时,需确定两个重要的方面:
1)字符串内容的存储.两个极端情况
1.把一个字符串的全部内容存储在一块连续存储区里
2.把串中每个字符单独存入一个独立存储块,并将这些块链接起来
实际中完全可以采用某种中间方式,把一个串的字符序列分段保存在一组存储块里,并链接起这些存储块
2)串结束的表示.不同字符串的长度可能不同,如果采用连续表示方式,由于存储在计算机里的都是二进制编码,从存储内容
无法判断哪里时串的结束.所有,必须采用某种方式表示字符串的结束.两种基本方式
# 用一个专门的数据域记录字符串长度,就像前面连续表中的num域;
# 用一个特殊编码表示串结束,为此需要保证该编码不代表任何字符.

串替换:
一些问题:
# 被替换串t可能在s中多次出现
# t在s里的多次出现可能有重叠
# 在完成了一次子串代换后,应该从代入的新串之后继续工作
# 无法预知s里有t的几个独立出现
实际语言中的字符串

Python的字符串
Python标准类型str可以看作抽象的字符串概念的一个实现.str时一个不变类型,其对象创建后内容和长度都不变化,但不同
str对象的长度可能不同,因此需要在对象里记录字符串长度.
在Python官方实现中,str对象采用了一体式顺序表形式.
实际上,在一个str对象的头部,除了记录字符串长度外,还记录了一些解释器用于管理对象的信息,他们是为系统内部操作服务的

字符串匹配(子串查找)
子串匹配问题也被称为字符串匹配(string matching)或者字符串查找(string searching)
有些教科书里称为模式匹配(pattern matching),但实际上,模式匹配是一个内涵更广的概念
字符串匹配就是在t中查找与p相同的子串的操作(或过程).
称t为目标串,称p为模式串
串匹配和朴素匹配算法
串匹配算法:做字符串匹配的基础是逐个比较字符
串匹配算法设计的两点关键:
# 怎样选择开始比较的字符对
# 发现不匹配后,下一步怎么做
朴素的串匹配算法:从左到右逐个字符匹配;发现不匹配时,转去考虑目标串里的下一个位置是否与模式串匹配
造成其低效的主要因素是执行中可能出现回溯:匹配遇到一对字符不同时,模式串p将右移一个字符位置,随后的匹配回到模式串
的开始(重置j=0),也回到目标串中前面的下一个位置,从那里再次由p0开始比较字符串
每次字符比较看作完全独立的操作,完全没有利用字符串本身的特点(每个字符串都是特殊的,只有有穷多个不同字符,等等),
也没用尽可能地利用前面已经做过的字符比较中得到的信息.
无回溯串匹配算法(KMP算法)
由于模式串在匹配之前已知,而且通常在匹配中反复使用,如果先对模式串做一些分析,记录得到的有用信息(如其中哪些位置
的字符相同或不同),就有可能避免一些不必要的匹配,提高匹配效率.这种做法是实际匹配前的静态预处理,只需要做一次.
记录下来的信息可以在匹配中反复使用
KMP算法的精髓就是开发了一套分析和记录模式串信息的机制(和算法),而后借助得到的信息加速匹配.
KMP算法的基本思想是匹配中不回溯.如果匹配中用模式串里的pi匹配某个tj时失败了(遇到了pj!=tj的情况),就找到某个特定
的ki(0<=ki<i),下一步用模式串中字符pki与目标串里的tj比较.也就是说,在匹配失败时把模式串前移若干位置,用模式串里
匹配失败字符之前的某个字符与目标串中匹配失败的字符比较.
KMP算法设计中的关键认识是:在pi匹配失败时,所有的pk(0<=k<i)都已经匹配成功(否则就不会考虑pi的匹配问题).这也就是说
在目标串中tj之前的i个字符也就是模式串p的前i个字符.这一情况说明,原本似乎应该根据目标串t中tj之前已匹配的一段来
决定模式串的前移位置,实际上只需根据模式串p本身的情况就可以决定了.这说明,完全可以在实际地与任何目标串匹配之前,
通过对模式串本身的分析,解决好匹配失败时应该怎样前移的问题.
确定k的问题变成确定p0....pi-1的相等前缀和后缀的长度;k值越小移动越远.
应该找的k是p0...pi-1的最长的相等前缀和后缀(不包括本身,但可以是空串)的长度
模式串右移i-k位,即把pnext[i]设置为k

递推计算最长相等前后缀的长度
许多场景中需要用一个模式串反复在一个或多个目标串里匹配.
可以考虑一个模式类型,将pnext表作为模式对象的一个成分,在以模式串作为参数构造模式对象做好对象的pnext表.实际匹配函数使用模式对象去匹配目标串.

字符串匹配问题
串匹配/搜索的不同需要
查找某种形式的字符串:考虑一组模式串,可能有穷,也可能无穷
考虑字符串集合的描述,以及对于是否属于一个字符串集合的检查
