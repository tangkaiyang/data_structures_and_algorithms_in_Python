线性表(简称表)是一组元素(的序列)的抽象.一个线性表是某类元素的一个集合,还记录着元素之间的一种顺序关系
Python语言的内置类型list和tuple都以具体的方式支持程序里的这类需要,都可以看作线性表的实现
下一个关系,顺序关系,即线性关系,线性表示一种线性结构
对于表L=(e0, e1, ..., en-1),其下一个关系是二元组的集合{<e0, e1>, <e1, e2>, ..., <en-2, en-1>}
唯一的首元素和唯一的尾元素(末元素)
除首元素,表中的每个元素都有且仅有一个前驱元素;
除了尾元素之外的每个元素都有且仅有一个后继元素

线性表的操作:
# 为创建操作提供初始元素序列
# 定义一些获取表中信息的解析操作
# 动态改变表的内容,
# 涉及一个或两个表的操作
# 涉及对表中每一个元素进行的操作.这是一个操作类.这类操作在进行中需要逐个访问表中元素,对每个元素做同样的事情.
这是一种操作模式,称为对表元素的遍历
变动操作:实际修改被操作的表,在该表上直接实现操作的效果
非变动操作:让操作总是建立一个新表,与原表相比是多了(加入了)或少了(删除了)一个或一些元素,或者每个元素都按特定方式修改
表抽象数据类型:
ADT List:                       # 一个表抽象数据类型
    List(self)                  # 表构造操作,创建一个新表
    is_empty(self)              # 判断self是否为一个空表
    len(self)                   # 获得self的长度
    prepend(self, elem)         # 将元素elem加入表中作为第一个元素
    append(self, elem)          # 将元素elem加入表中作为最后一个元素
    insert(self, elem, i)       # 将elem加入表中作为第i个元素,其他元素的顺序不变
    del_first(self)             # 删除表中的首元素
    del_last(self)              # 删除表中的尾元素
    del(self, i)                # 删除表中第i个元素
    search(self, elem)          # 查找元素elem在表中出现的位置,不出现返回-1
    forall(self, op)            # 对表中的每个元素执行操作op

线性表的实现:基本考虑
1)计算机内存的特点,以及保存元素和元素顺序信息的需要
2)各种重要操作的效率.如果程序里需要一个表,其创建操作只执行一次,但在其存在期间,可能反复地多次以各种方式使用,
其中使用最频繁的操作通常保罗表的性质判断函数is_empty等,还有(定位)访问,加入和删除元素,元素遍历等.在考虑表的实现
结构时,需要特别考虑这些操作的实现效率
两种基本的实现模型:
1)将表中元素顺序地存放在一大块连续的存储区里,这样实现的表也称为顺序表(或连续表).在这种实现中,元素键的顺序关系
由他们的存储顺序自然表示
2)将表元素存放在通过连接构造起来的一系列存储块里,这样实现的表称为链接表,简称链表.

顺序表的实现
顺序表的基本实现方式很简单:表中元素顺序存放在一片足够大的连续存储区里,首元素(第一个元素)存入存储区的开始位置,
其余元素依次顺序存放.元素之间的逻辑顺序关系通过元素在存储区里的物理位置表示(隐式表示元素间的关系)
基本实现方式
最常见情况:一个表里保存的元素类型相同,因此存储每个表元素所需的存储量相同,可以在表里等距离安排相同大小的存储位置.
这种安排可以直接映射到计算机内存和单元,表中任何元素位置的计算非常简单,存取操作可以在O(1)时间内完成
如果表元素的大小不统一,按照上面方案将元素顺序存入元素存储区,将无法通过统一公式计算元素位置.
这时可以采用另一种布局方案,将实际数据元素另行存储,在顺序表里各单元位置保存对相应元素的引用信息(链接).
由于每个连接所需的存储量相同,通过上述统一公式,可以计算出元素链接的存储位置,而后顺链接做一次间接访问,就能得到
实际元素的数据了.
顺序表里保存的不是实际数据,而是找到实际数据的线索,这样的顺序表也被称为对实际数据的索引,这是最简单的索引结构,
线性表的一个重要性质是可以加入/删除元素,在一个表的存续期间,其长度(其中元素的个数)可能变化.这就带来了一个问题:
在建立一个表时,应该安排多大的一块存储区?表元素存储块需要安排在计算机内存中,一旦分配了就占据内存里的一块区域,
有了固定的大小(并因此确定了容量,即确定了元素个数的上限)而且,该块的前后都可能被其他有用对象占据,存储块的大小不能
随便变化,特别是无法扩充.
在建立一个顺序表时,一种可能是按建立时确定的元素个数分配存储.这种做法适合创建不变的顺序表,例如Python中的tuple对象
如果考虑的是变动的表,就必须区分表中(当前的)元素个数和元素存储区的容量.在建立这种表时,一个合理的方法是分配一块足以容纳当前需要记录的元素的存储块,还应该保留一些空间,以满足增加元素的需要.
需要记录元素存储区的大小和当前的元素个数.
顺序表基本操作的实现
max表示表的容量,num表示当前元素个数
创建和访问操作:
创建空表:创建空表时,需要分配一块元素存储,记录表的容量并将元素计数值设置为0.注意,创建新表的存储区后,应立即将两个表
信息记录域(max和num)设置好,保证这个表处于合法状态
简单判断操作:
访问给定下标i的元素:
遍历操作:
查找给定元素d的(第一次出现的)位置:这种操作称为检索或查找(searching).在没有其他信息的情况下,只能通过用d与表中
元素逐个比较的方式实现检索,称为线性检索.
查找给定元素d在位置k之后的第一次出现的位置:
总结:不修改表表结构的操作只有两种模式,或者是直接访问,或者是基于一个整型变量,按小标循环并检查和处理.
前一类操作都具有O(1)的时间复杂度,后一类操作与访问的元素个数有关,复杂度为O(n),n是表中元素个数
变动操作:加入元素
变动操作,即各种加入和删除元素的操作
尾端加入新数据项:
新数据存入元素存储区的第i个单元:
如果操作不要求维持原有元素的相对位置(不要求保序),可以采用简单处理方式:把原来位于i的元素移到位置num,放到其他已有元素之后,腾出位置i放入新元素,最后把元素计数值num加1.这一操作仍能在O(1)时间完成
如果操作要求位置原有元素的顺序(保序),就不能像上面那样简单地腾出空位,必须把插入位置i之后的元素逐一下移,最后把数
据项存入i位置.这样操作的开销与移动元素的个数成正比,一般而言受限于表中元素个数,最坏和平均情况都是O(n)
变动操作:删除元素
尾端删除数据:
删除位置i的数据:保序与非保序
基于条件的删除:这种删除操作不是给定被删元素的位置,而是给出需要删除的数据项d本身,或者是给出一个条件要求删除满足这个
条件的(一个,几个或者所以)元素.显然,这种操作与前面讨论过的检索有关,需要找打元素后删除它或它们.
这种操作也需要通过循环实现,循环中逐个检查元素,查到要找的元素后删除
顺序表及其操作的性质
# 优点:O(1)时间的(随机,直接的)按位置访问元素;元素在表里存储紧凑,除表元素存储区之外只需要O(1)空间存放少量辅助信息
# 缺点:需要连续的存储区存放表中的元素,如果表很大,就需要很大片的连续内存空间.一旦确定了存储块的大小,可容纳单元个数并不随着插入/
删除操作的进行而变化.如果很大的存储区里只保存了少量数据项,就会有大量空闲单元,造成表内的存储浪费.另外,在执行加入或删除操作时,
通常需要移动许多元素,效率低.最后,建立表时需要考虑元素存储区大小,而实际需求通常很难事先估计.
顺序表的结构
两种基本实现方式:
一体式结构:存储表信息的单元与元素存储区以连续的方式安排在一块存储区里
分离式结构:表对象里只保存与整个表有关的信息(容量和元素个数),实际元素存放在另一个独立的元素存储区对象里,通过链接与基本表对象关联
替换元素存储区:分离式实现的最大优点:可以在标识不变的情况下,为表对象换一块元素存储区.
动态顺序表,其容量可以在使用中动态变化
后端插入和存储区扩充
应该怎样选择新存储区的大小?牵涉到空闲存储单元的量和替换存储的频度问题
一种简单的策略:每次替换存储时增加10个元素存储位置.这种策略可称为线性增长,10是增长的参数
考虑一种策略,其中随着元素数量的增加,替换存储区的频率不断降低:容量加倍
还有一个问题值得注意:动态顺序表后端插入的代价不统一,大多数可以在O(1)时间内完成,但也会因为替换存储区而出现高代价操作.
缓解上述问题:增加一个设定容量的操作

Python的list
tuple是不变的表,因此不支持改变其内部状态的任何操作.在其他方面,与list性质类似
list是一种采用分离技术实现的动态顺序表
lst.insert(len(lst),x)比在一般位置插入的效率高.与lst.append(x)等价

顺序表的简单总结
采用顺序表结构实现线性表:
# 最重要特点(优势)是O(1)时间的定位元素访问.很多简单操作的效率也比较高
# 这里最重要的麻烦是加入/删除等操作的效率问题.这类操作改变表中元素序列的结构,是典型的的变动操作.由于元素在顺序表的存储区里连续
排列,加入/删除操作有可能要移动很多元素,操作代价高
# 只有特殊的尾端插入/删除操作具有O(1)时间复杂度.但插入操作复杂度还受到元素存储区固定大小的限制.通过恰当的(加倍)存储区扩充策略,
一系列尾端插入可以达到O(1)的平均复杂度

顺序表的优点和缺点都在于其元素存储的集中方式和连续性.从缺点看,这样的表结构不够灵活,不容易调整和变化.如果在一个表的使用中需要
经常修改结构,用顺序表去实现就不太方便,反复操作的代价可能提高
如果程序里需要巨大的线性表,采用顺序表实现就需要巨大块的连续存储空间,这也可能造成存储管理方面的困难
链接表在这两方面都有优势
链接表
线性表的基本需要是:
# 能够找到表中的首元素(无论直接或间接,这件事通常很容易做到)
# 从表里的任一元素出发,可以找到它之后的下一个元素
把表元素保存在连续的存储区里(顺序表),自然能满足这两个需求,其中元素间的顺序关联是隐含的.
但是,要满足这两种需求,并不一定需要连续存储元素.
显然,对象之间的链接也可以看做一种顺序关联,基于它可以实现线性表
实现线性表的另一种常用方式就是基于链接结构,用链接关系显式表示元素之间的顺序关联.基于链接技术实现的线性表称为链接表或链表
采用链接方式实现线性表的基本想法:
# 把表中的元素分别存储在一批独立的存储块(称为表的结点)里
# 保证从组成表结构中的任一结点可以找到与其相关的下一个结点
# 在前一结点里用链接的方式显式地记录与下一结点之间的关联
单链表:每个表结点里记录着存储下一个表元素的结点的标识(引用/链接).
"存储着下一个表元素的结点"在书中简称为"下一个结点"
单链表:
单向链接表(下面简称为单链表或链表)的结点是一个二元组.
其表元素域elem保存着作为表元素的数据项(或者数据项的关联信息),链接域next里保存同一个表里的下一个结点的标识
掌握一个单链表,就需要(也只需要)掌握这个表的首结点,从他出发可以找到这个表里的第一个元素(即在这个表结点里保存的数据,保存在它的
elem域中),还可以找到这个表里的下一个结点(有关信息保存在这个结点的next域中).
掌握一个表,只需要用一个变量保存着这个表的首节点的引用(标识或称为链接).这样的变量称为表头变量或表头指针
# 一个单链表由一些具体的表结点构成
# 每个结点是一个对象,有自己的标识,下面也长称其为该结点的链接
# 结点之间通过结点链接建立起单向的顺序联系
为了标识一个链表的结束,只需给表的最后结点(表尾结点)的链接域设置一个不会作为结点对象标识的值(称为空连接),
基本链表操作
创建空链表:只需要把对应的表头变量设置为空链接
删除链表:应丢弃这个链表里的所有结点
判断表是否为空:将表头变量的值与空链接比较.Python中,就是检查相应变量的值是否为None
判断表是否满:一般而言链表不会满,除非程序用完了所有可用的存储空间
加入元素
在链表里加入新元素时,并不需要移动已有的数据,只需要为新元素安排一个新结点,然后根据操作要求,把新结点连在表中的正确位置.
插入新元素的操作是通过修改链接,接入新结点,从而改变表结构的方式实现的
表首端插入:
一般情况的元素插入:
删除元素
删除表首元素:
一般情况的元素删除:
扫描,定位和遍历:
由于单链表只有一个方向的链接,开始情况下只有表头变量在掌握中,所以对表内容的一切检查都只能以表头变量开始,沿着表中链接逐步进行.
这种操作过程称为链表的扫描,这种过程的基本操作模式是:
p = head
while p is not None and 还需继续的其他条件:
    对p所指结点里的数据做所需操作
    p = p.next
循环中使用的辅助变量p称为扫描指针.注意,每个扫描循环必须用一个扫描指针作为控制变量,每步迭代前必须检查其值是否为None,保证随后
操作的合法性.
按下标定位:按Python惯例,链表首节点的元素应看做下标0,其他元素一次排列.确定第i个元素所在节点的操作称为按下表定位,
p = head
while p is not None and i > 0:
    i -= 1
    p = p.next
假设循环前变量i已有所需的值,循环结束时可能出现两种情况:或者扫描完表中所有节点还没有找到第i个结点,或者p所指节点就是所需.
通过检查p值是否为None可以区分这两种情况.
显然,如果现在需要删除第k个结点,可以先将i设置为k-1,循环后检查i是0且p.next不是None就可以执行删除了
按元素定位:假设需要在链表里找到满足谓词pred的元素.同样可以参考上面的表扫描模式,写出的检索循环如下:
p = head
while p is not None and not pred(p.elem):
    p = p.next
循环结束时或者p是None,或者pred(p.elem)是True,找到了所需元素
链表操作的复杂度
# 创建空表:O(1)
# 删除表:在Python里是O(1).Python解释器做存储管理也需要时间
# 判断空表:O(1)
# 加入元素(都需要加一个T(分配)的时间):
# # 首端加入元素:O(1)
# # 尾端加入元素:O(n),因为需要找到表的最后结点
# # 定位加入元素:O(n),平均情况和最坏情况
# 删除元素
# # 首端删除元素:O(1)
# # 尾端删除元素:O(n)
# # 定位删除元素:O(n),平均情况和最坏情况
# # 其他删除:通常需要扫描整个表或其一部分,O(n)
求表的长度
def length(head):
    p, n = head, 0
    while p is not None:
        n += 1
        p = p.next
    return n
实现方式的变化
以求表的长度为例,如果程序经常需要调用上面函数,O(n)复杂度就可能成为效率问题.如果表很长,执行该函数就可能造成
可察觉的停顿.解决这个问题的一种方法是改造单链表的实现结构,增加一个表长度记录.显然,这个记录不属于任何表元素
是有关表的整体的信息.表示这件事的恰当方法是定义一种链表对象,把表的长度和表中的结点链表都作为这个表对象的数据
成分.求表长度的操作就可以简单返回元素计数域的值.但另一方面,这种表的每个变动操作都需要维护计数值.
从整体看有得有失.这种调整消除了一个线性时间操作,可能在一些应用中很有意义.

单链表类的实现linklist.py
自定义异常
LList类的定义,初始化函数和简单操作
后端操作
其他操作

表的遍历:线性表一类的对象称为汇集(collection)对象,他们本身是对象,其中又包含着一组元素对象.
Python内置的list,tuple等都是汇集对象类.
对于汇集对象,最典型的使用方法之一就是逐个使用其中的元素,这种操作称为遍历.
传统的遍历方式是为汇集对象类定义一个遍历函数,它以一个操作为参数,将其作用到汇集对象的每个元素上
def for_each(self, proc):
    p = self._head
    while p is not None:
        proc(p.elem)
        p = p.next
proc的实参应该是可以作用于表元素的操作函数,它将被作用于每个表元素.
假如list1是以字符串为元素的表,下面语句将一行一个地输出这些字符串:
list1.foreach(print)
优点是比较规范,缺点是使用不够灵活,不容易与其他编程机制配合使用.
为了解决使用中的不便,人们经常用lambda表达式定制出在这里使用的操作参数
遍历一组数据是程序中最重要的一类工作方式,新型编程语言都为这类操作提供了专门的支持工具,特别是希望能把用户定义类型的处理纳入统一的编程形式中.
Python语言为内部汇集类型提供的遍历机制是迭代器,标准使用方式是放在for语句头部,在循环体中逐个处理汇集对象的元素,
这样就可以很方便地实施各种操作.LList是汇集类型,因此也应该为它提供类似的操作方式,使之能用在标准的操作框架里.

筛选生成器:

链表的变形和操作
单链表的简单变形
单链表(即每个结点只有一个指针域)
前面单链表实现有一个缺点:尾端加入元素操作的效率低,因为这是只能从表头开始查找,直到找到表的最后一个结点,而后才能链接新结点
一种可行设计:表对象增加一个表尾结点引用域.有了这个域,只需常量时间就能找到尾结点,在表尾加入新结点的操作就可能做到O(1)
应该注意到:链表的这一新设计与前面单链表的结构近似,这种结构变化应该不影响非变动操作的实现,只影响到表的变动操作.
在这种情况下,有可能重用前面定义(或者前面定义的一部分)吗?
通过继承和扩充定义新链表类
初始化和变动操作