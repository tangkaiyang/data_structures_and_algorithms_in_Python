线性表(简称表)是一组元素(的序列)的抽象.一个线性表是某类元素的一个集合,还记录着元素之间的一种顺序关系
Python语言的内置类型list和tuple都以具体的方式支持程序里的这类需要,都可以看作线性表的实现
下一个关系,顺序关系,即线性关系,线性表示一种线性结构
对于表L=(e0, e1, ..., en-1),其下一个关系是二元组的集合{<e0, e1>, <e1, e2>, ..., <en-2, en-1>}
唯一的首元素和唯一的尾元素(末元素)
除首元素,表中的每个元素都有且仅有一个前驱元素;
除了尾元素之外的每个元素都有且仅有一个后继元素

线性表的操作:
# 为创建操作提供初始元素序列
# 定义一些获取表中信息的解析操作
# 动态改变表的内容,
# 涉及一个或两个表的操作
# 涉及对表中每一个元素进行的操作.这是一个操作类.这类操作在进行中需要逐个访问表中元素,对每个元素做同样的事情.
这是一种操作模式,称为对表元素的遍历
变动操作:实际修改被操作的表,在该表上直接实现操作的效果
非变动操作:让操作总是建立一个新表,与原表相比是多了(加入了)或少了(删除了)一个或一些元素,或者每个元素都按特定方式修改
表抽象数据类型:
ADT List:                       # 一个表抽象数据类型
    List(self)                  # 表构造操作,创建一个新表
    is_empty(self)              # 判断self是否为一个空表
    len(self)                   # 获得self的长度
    prepend(self, elem)         # 将元素elem加入表中作为第一个元素
    append(self, elem)          # 将元素elem加入表中作为最后一个元素
    insert(self, elem, i)       # 将elem加入表中作为第i个元素,其他元素的顺序不变
    del_first(self)             # 删除表中的首元素
    del_last(self)              # 删除表中的尾元素
    del(self, i)                # 删除表中第i个元素
    search(self, elem)          # 查找元素elem在表中出现的位置,不出现返回-1
    forall(self, op)            # 对表中的每个元素执行操作op

线性表的实现:基本考虑
1)计算机内存的特点,以及保存元素和元素顺序信息的需要
2)各种重要操作的效率.如果程序里需要一个表,其创建操作只执行一次,但在其存在期间,可能反复地多次以各种方式使用,
其中使用最频繁的操作通常保罗表的性质判断函数is_empty等,还有(定位)访问,加入和删除元素,元素遍历等.在考虑表的实现
结构时,需要特别考虑这些操作的实现效率
两种基本的实现模型:
1)将表中元素顺序地存放在一大块连续的存储区里,这样实现的表也称为顺序表(或连续表).在这种实现中,元素键的顺序关系
由他们的存储顺序自然表示
2)将表元素存放在通过连接构造起来的一系列存储块里,这样实现的表称为链接表,简称链表.

顺序表的实现
顺序表的基本实现方式很简单:表中元素顺序存放在一片足够大的连续存储区里,首元素(第一个元素)存入存储区的开始位置,
其余元素依次顺序存放.元素之间的逻辑顺序关系通过元素在存储区里的物理位置表示(隐式表示元素间的关系)
基本实现方式
最常见情况:一个表里保存的元素类型相同,因此存储每个表元素所需的存储量相同,可以在表里等距离安排相同大小的存储位置.
这种安排可以直接映射到计算机内存和单元,表中任何元素位置的计算非常简单,存取操作可以在O(1)时间内完成
如果表元素的大小不统一,按照上面方案将元素顺序存入元素存储区,将无法通过统一公式计算元素位置.
这时可以采用另一种布局方案,将实际数据元素另行存储,在顺序表里各单元位置保存对相应元素的引用信息(链接).
由于每个连接所需的存储量相同,通过上述统一公式,可以计算出元素链接的存储位置,而后顺链接做一次间接访问,就能得到
实际元素的数据了.
顺序表里保存的不是实际数据,而是找到实际数据的线索,这样的顺序表也被称为对实际数据的索引,这是最简单的索引结构,
线性表的一个重要性质是可以加入/删除元素,在一个表的存续期间,其长度(其中元素的个数)可能变化.这就带来了一个问题:
在建立一个表时,应该安排多大的一块存储区?表元素存储块需要安排在计算机内存中,一旦分配了就占据内存里的一块区域,
有了固定的大小(并因此确定了容量,即确定了元素个数的上限)而且,该块的前后都可能被其他有用对象占据,存储块的大小不能
随便变化,特别是无法扩充.
在建立一个顺序表时,一种可能是按建立时确定的元素个数分配存储.这种做法适合创建不变的顺序表,例如Python中的tuple对象
如果考虑的是变动的表,就必须区分表中(当前的)元素个数和元素存储区的容量.在建立这种表时,一个合理的方法是分配一块足以容纳当前需要记录的元素的存储块,还应该保留一些空间,以满足增加元素的需要.
需要记录元素存储区的大小和当前的元素个数.
顺序表基本操作的实现
max表示表的容量,num表示当前元素个数
创建和访问操作:
创建空表:创建空表时,需要分配一块元素存储,记录表的容量并将元素计数值设置为0.注意,创建新表的存储区后,应立即将两个表
信息记录域(max和num)设置好,保证这个表处于合法状态
简单判断操作:
访问给定下标i的元素:
遍历操作:
查找给定元素d的(第一次出现的)位置:这种操作称为检索或查找(searching).在没有其他信息的情况下,只能通过用d与表中
元素逐个比较的方式实现检索,称为线性检索.
查找给定元素d在位置k之后的第一次出现的位置:
总结:不修改表表结构的操作只有两种模式,或者是直接访问,或者是基于一个整型变量,按小标循环并检查和处理.
前一类操作都具有O(1)的时间复杂度,后一类操作与访问的元素个数有关,复杂度为O(n),n是表中元素个数
变动操作:加入元素
变动操作,即各种加入和删除元素的操作
尾端加入新数据项:
新数据存入元素存储区的第i个单元:
如果操作不要求维持原有元素的相对位置(不要求保序),可以采用简单处理方式:把原来位于i的元素移到位置num,放到其他已有元素之后,腾出位置i放入新元素,最后把元素计数值num加1.这一操作仍能在O(1)时间完成
如果操作要求位置原有元素的顺序(保序),就不能像上面那样简单地腾出空位,必须把插入位置i之后的元素逐一下移,最后把数
据项存入i位置.这样操作的开销与移动元素的个数成正比,一般而言受限于表中元素个数,最坏和平均情况都是O(n)
变动操作:删除元素
尾端删除数据:
删除位置i的数据:保序与非保序
基于条件的删除:这种删除操作不是给定被删元素的位置,而是给出需要删除的数据项d本身,或者是给出一个条件要求删除满足这个
条件的(一个,几个或者所以)元素.显然,这种操作与前面讨论过的检索有关,需要找打元素后删除它或它们.
这种操作也需要通过循环实现,循环中逐个检查元素,查到要找的元素后删除
顺序表及其操作的性质
# 优点:O(1)时间的(随机,直接的)按位置访问元素;元素在表里存储紧凑,除表元素存储区之外只需要O(1)空间存放少量辅助信息
# 缺点:需要连续的存储区存放表中的元素,如果表很大,就需要很大片的连续内存空间.一旦确定了存储块的大小,可容纳单元个数并不随着插入/
删除操作的进行而变化.如果很大的存储区里只保存了少量数据项,就会有大量空闲单元,造成表内的存储浪费.另外,在执行加入或删除操作时,
通常需要移动许多元素,效率低.最后,建立表时需要考虑元素存储区大小,而实际需求通常很难事先估计.
顺序表的结构
两种基本实现方式:
一体式结构:存储表信息的单元与元素存储区以连续的方式安排在一块存储区里
分离式结构:表对象里只保存与整个表有关的信息(容量和元素个数),实际元素存放在另一个独立的元素存储区对象里,通过链接与基本表对象关联
替换元素存储区:分离式实现的最大优点:可以在标识不变的情况下,为表对象换一块元素存储区.
动态顺序表,其容量可以在使用中动态变化
后端插入和存储区扩充
应该怎样选择新存储区的大小?牵涉到空闲存储单元的量和替换存储的频度问题
一种简单的策略:每次替换存储时增加10个元素存储位置.这种策略可称为线性增长,10是增长的参数
考虑一种策略,其中随着元素数量的增加,替换存储区的频率不断降低:容量加倍
还有一个问题值得注意:动态顺序表后端插入的代价不统一,大多数可以在O(1)时间内完成,但也会因为替换存储区而出现高代价操作.
缓解上述问题:增加一个设定容量的操作

Python的list
tuple是不变的表,因此不支持改变其内部状态的任何操作.在其他方面,与list性质类似
list是一种采用分离技术实现的动态顺序表
lst.insert(len(lst),x)比在一般位置插入的效率高.与lst.append(x)等价

顺序表的简单总结
采用顺序表结构实现线性表:
# 最重要特点(优势)是O(1)时间的定位元素访问.很多简单操作的效率也比较高
# 这里最重要的麻烦是加入/删除等操作的效率问题.这类操作改变表中元素序列的结构,是典型的的变动操作.由于元素在顺序表的存储区里连续
排列,加入/删除操作有可能要移动很多元素,操作代价高
# 只有特殊的尾端插入/删除操作具有O(1)时间复杂度.但插入操作复杂度还受到元素存储区固定大小的限制.通过恰当的(加倍)存储区扩充策略,
一系列尾端插入可以达到O(1)的平均复杂度

顺序表的优点和缺点都在于其元素存储的集中方式和连续性.从缺点看,这样的表结构不够灵活,不容易调整和变化.如果在一个表的使用中需要
经常修改结构,用顺序表去实现就不太方便,反复操作的代价可能提高
如果程序里需要巨大的线性表,采用顺序表实现就需要巨大块的连续存储空间,这也可能造成存储管理方面的困难
链接表在这两方面都有优势
链接表
线性表的基本需要是:
# 能够找到表中的首元素(无论直接或间接,这件事通常很容易做到)
# 从表里的任一元素出发,可以找到它之后的下一个元素
把表元素保存在连续的存储区里(顺序表),自然能满足这两个需求,其中元素间的顺序关联是隐含的.
但是,要满足这两种需求,并不一定需要连续存储元素.
显然,对象之间的链接也可以看做一种顺序关联,基于它可以实现线性表
实现线性表的另一种常用方式就是基于链接结构,用链接关系显式表示元素之间的顺序关联.基于链接技术实现的线性表称为链接表或链表
采用链接方式实现线性表的基本想法:
# 把表中的元素分别存储在一批独立的存储块(称为表的结点)里
# 保证从组成表结构中的任一结点可以找到与其相关的下一个结点
# 在前一结点里用链接的方式显式地记录与下一结点之间的关联
单链表:每个表结点里记录着存储下一个表元素的结点的标识(引用/链接).
"存储着下一个表元素的结点"在书中简称为"下一个结点"
单链表:
单向链接表(下面简称为单链表或链表)的结点是一个二元组.
其表元素域elem保存着作为表元素的数据项(或者数据项的关联信息),链接域next里保存同一个表里的下一个结点的标识
掌握一个单链表,就需要(也只需要)掌握这个表的首结点,从他出发可以找到这个表里的第一个元素(即在这个表结点里保存的数据,保存在它的
elem域中),还可以找到这个表里的下一个结点(有关信息保存在这个结点的next域中).
掌握一个表,只需要用一个变量保存着这个表的首节点的引用(标识或称为链接).这样的变量称为表头变量或表头指针
# 一个单链表由一些具体的表结点构成
# 每个结点是一个对象,有自己的标识,下面也长称其为该结点的链接
# 结点之间通过结点链接建立起单向的顺序联系
为了标识一个链表的结束,只需给表的最后结点(表尾结点)的链接域设置一个不会作为结点对象标识的值(称为空连接),
基本链表操作
创建空链表:只需要把对应的表头变量设置为空链接
删除链表:应丢弃这个链表里的所有结点
判断表是否为空:将表头变量的值与空链接比较.Python中,就是检查相应变量的值是否为None
判断表是否满:一般而言链表不会满,除非程序用完了所有可用的存储空间
加入元素
在链表里加入新元素时,并不需要移动已有的数据,只需要为新元素安排一个新结点,然后根据操作要求,把新结点连在表中的正确位置.
插入新元素的操作是通过修改链接,接入新结点,从而改变表结构的方式实现的
表首端插入:
一般情况的元素插入:
删除元素
删除表首元素:
一般情况的元素删除:
扫描,定位和遍历:
由于单链表只有一个方向的链接,开始情况下只有表头变量在掌握中,所以对表内容的一切检查都只能以表头变量开始,沿着表中链接逐步进行.
这种操作过程称为链表的扫描,这种过程的基本操作模式是:
p = head
while p is not None and 还需继续的其他条件:
    对p所指结点里的数据做所需操作
    p = p.next
循环中使用的辅助变量p称为扫描指针.注意,每个扫描循环必须用一个扫描指针作为控制变量,每步迭代前必须检查其值是否为None,保证随后
操作的合法性.
按下标定位:按Python惯例,链表首节点的元素应看做下标0,其他元素一次排列.确定第i个元素所在节点的操作称为按下表定位,
p = head
while p is not None and i > 0:
    i -= 1
    p = p.next
假设循环前变量i已有所需的值,循环结束时可能出现两种情况:或者扫描完表中所有节点还没有找到第i个结点,或者p所指节点就是所需.
通过检查p值是否为None可以区分这两种情况.
显然,如果现在需要删除第k个结点,可以先将i设置为k-1,循环后检查i是0且p.next不是None就可以执行删除了
按元素定位:假设需要在链表里找到满足谓词pred的元素.同样可以参考上面的表扫描模式,写出的检索循环如下:
p = head
while p is not None and not pred(p.elem):
    p = p.next
循环结束时或者p是None,或者pred(p.elem)是True,找到了所需元素
链表操作的复杂度
# 创建空表:O(1)
# 删除表:在Python里是O(1).Python解释器做存储管理也需要时间
# 判断空表:O(1)
# 加入元素(都需要加一个T(分配)的时间):
# # 首端加入元素:O(1)
# # 尾端加入元素:O(n),因为需要找到表的最后结点
# # 定位加入元素:O(n),平均情况和最坏情况
# 删除元素
# # 首端删除元素:O(1)
# # 尾端删除元素:O(n)
# # 定位删除元素:O(n),平均情况和最坏情况
# # 其他删除:通常需要扫描整个表或其一部分,O(n)
求表的长度
def length(head):
    p, n = head, 0
    while p is not None:
        n += 1
        p = p.next
    return n
实现方式的变化
以求表的长度为例,如果程序经常需要调用上面函数,O(n)复杂度就可能成为效率问题.如果表很长,执行该函数就可能造成
可察觉的停顿.解决这个问题的一种方法是改造单链表的实现结构,增加一个表长度记录.显然,这个记录不属于任何表元素
是有关表的整体的信息.表示这件事的恰当方法是定义一种链表对象,把表的长度和表中的结点链表都作为这个表对象的数据
成分.求表长度的操作就可以简单返回元素计数域的值.但另一方面,这种表的每个变动操作都需要维护计数值.
从整体看有得有失.这种调整消除了一个线性时间操作,可能在一些应用中很有意义.

单链表类的实现linklist.py
自定义异常
LList类的定义,初始化函数和简单操作
后端操作
其他操作

表的遍历:线性表一类的对象称为汇集(collection)对象,他们本身是对象,其中又包含着一组元素对象.
Python内置的list,tuple等都是汇集对象类.
对于汇集对象,最典型的使用方法之一就是逐个使用其中的元素,这种操作称为遍历.
传统的遍历方式是为汇集对象类定义一个遍历函数,它以一个操作为参数,将其作用到汇集对象的每个元素上
def for_each(self, proc):
    p = self._head
    while p is not None:
        proc(p.elem)
        p = p.next
proc的实参应该是可以作用于表元素的操作函数,它将被作用于每个表元素.
假如list1是以字符串为元素的表,下面语句将一行一个地输出这些字符串:
list1.foreach(print)
优点是比较规范,缺点是使用不够灵活,不容易与其他编程机制配合使用.
为了解决使用中的不便,人们经常用lambda表达式定制出在这里使用的操作参数
遍历一组数据是程序中最重要的一类工作方式,新型编程语言都为这类操作提供了专门的支持工具,特别是希望能把用户定义类型的处理纳入统一的编程形式中.
Python语言为内部汇集类型提供的遍历机制是迭代器,标准使用方式是放在for语句头部,在循环体中逐个处理汇集对象的元素,
这样就可以很方便地实施各种操作.LList是汇集类型,因此也应该为它提供类似的操作方式,使之能用在标准的操作框架里.

筛选生成器:

链表的变形和操作
单链表的简单变形
单链表(即每个结点只有一个指针域)
前面单链表实现有一个缺点:尾端加入元素操作的效率低,因为这是只能从表头开始查找,直到找到表的最后一个结点,而后才能链接新结点
一种可行设计:表对象增加一个表尾结点引用域.有了这个域,只需常量时间就能找到尾结点,在表尾加入新结点的操作就可能做到O(1)
应该注意到:链表的这一新设计与前面单链表的结构近似,这种结构变化应该不影响非变动操作的实现,只影响到表的变动操作.
在这种情况下,有可能重用前面定义(或者前面定义的一部分)吗?
通过继承和扩充定义新链表类
初始化和变动操作

类设计的内在一致性
类设计中的一个重要原则:
一个类定义是一个整体,它描述了一种程序对象.类定义比较复杂,其中可用又许多成分,特别是可能定义了许多方法.每个方法
定义是类定义中的一个独立片段,编程语言(Python)对不同方法之间的关系并没有任何约束,也不对这样一组方法定义做任何
相互关系方面的检查.但是,作为同一类定义的成分,这些方法需要相互协调,保持一致,才能保证所定义的程序对象有意义.
这件事需要编程序的人考虑和保证
一般情况,在设计一个类是总需要考虑一套统一的规则.类的初始化方法建立起的对象应满足这些规则,操作也不能破坏规则,
这样定义的类才是有效的.
当然,不同规则可能影响类定义的细节和复杂程度.

循环单链表
单链表的另一常见变形是循环单链表(简称循环链表),其中最后一个结点的next域不用None,而是指向表的第一个结点.
循环单链表类

双链表
单链表只有一个方向的链接,只能做一个方向的扫描和逐步操作.即使增加了尾结点引用,也只能支持O(1)时间的首端元素加入/
删除和尾端加入.如果希望两端插入和删除操作都能高效完成,就必须修改结点(从而也是链表)的基本设计,加入另一方向的链接.
这样就得到双向链接表,简称双链表.有了结点之间的双向链接,不仅能支持两端的高效操作,一般结点操作也会更加方便.
当然,这样做也需要付出代价:每个结点都需要增加一个链接域,增加的空间开销与结点数成正比,是O(n).
如果每个表结点里的数据规模比较大,新增加的开销可能就显得不太重要了.
为了支持首尾两端的高效操作,双链表包含一个尾节点引用域.从双链表任一结点出发,可用直接找到其前后的相邻结点
(都是O(1)操作).而对单链表而言,只能方便的找到下一个结点,要找前一结点,就必须从表头开始逐一检查(通过一次扫描)
可用直接找到当前结点的前后结点,使得双链表的许多操作都很容易地进行.
下面假定结点的下一结点引用域是next,前一结点引用域是prev
结点操作:
结点删除:
p.prev.next = p.next
p.next.prev = p.prev
双链表类
双链表的结点与单链表不同,因为结点里多了一个反向引用域.可用考虑独立定义,或者在LNode类的基础上派生

循环双链表
双链表也可以定义为循环链表,也就是说,让表尾结点的next域指向表的首结点,而让表首结点的prev域指向尾结点.
在这种表里,各结点的next引用形成了向下一结点方向的引用环,而各结点的prev引用形成向前一结点方向的引用环.
两个环相向而行.实际上,尾结点指针并不必要
由于在这种表里存在双向链接,无论是掌握着表的首结点还是尾节点,都能高效实现首尾两端的元素加入/删除操作(O(1)复杂度)

两个链表操作
链表反转
请注意,对顺序表而言,改变其中元素的顺序的方法只有一种,就是在表中搬动元素.而对于链表,实际上存在着两种方法:
可用在结点之间搬动元素,也可以修改结点的链接关系,通过改变结点的链接顺序来改变表元素的顺序
对于单链表,有一种情况很重要:在首端插入/删除元素或结点是最方便的操作,只需要O(1)时间.实现单链表操作时,
最好能在首端进行.
如果不断向一个表的首端插入结点,最早放进去的结点将在表的最后(即尾结点),而从表的首端取下结点,最后取下的是尾结点.
也就是说,从一个表的首端不断取下结点,将其加入另一个表的首端,就形成了一个反转过程.取下和加入操作都是O(1)的,
总时间开销是O(n),所有这个过程就是一个高效的反转算法

链表排序:对链表的元素进行排序
lst.sort()将lst中元素从小到大进行排序
sorted(lst)生成一个新的表(list类型的对象)其中元素是lst的元素排序的结果
插入排序,基本想法:
1)在操作过程中维护一个排好序的序列片段.初始时该段只包含一个元素,可用时任何一个元素,因为一个元素的序列总是应该
认为时排序的
2)每次从尚未处理的元素中去除一个元素,将其插入已排序片段中的正确位置,保持插入后的序列片段仍然时正确排序的
3)当所有元素都加入了排序的片段时,排序工作完成
两部分可用共用原来的表,例如在表前部积累排序片段,不需要额外的存储
排序过程中,被排序表的状态:下标i之前的段已经从小到大排序,从i开始的段尚未处理,下一步考虑位置i的元素d的插入问题,
并正确完成这一工作.这样一次处理一个元素后i值加一,直至i的值超出表的右端时排序完成.
一个元素的处理也需要通过一个循环.在这个循环中,需要维持已排序元素的相对顺序,并最终确定d的正确插入位置.循环
开始时取出d,使位置i变为空位.新下标变量j记录空位,并逐步左移.每次迭代将j-1位置的元素与d比较,如果d较小,就把位于
j-1的元素右移到j位置,并将j值减一(表示空位左移了).这样在j到i之间就会积累一段大于d的元素.反复做到位置j之前元素
不大于d时,将d放入空位.显然,直至i的子序列仍保持有序.
现在考虑单链表的排序算法.注意:由于这里只有next链接,扫描指针只能向下一方向移动,不能从后向前查找结点(或找元素).
另外,如前所述,这里也存在两种可能完成排序的做法:移动表中元素,或者调整结点之间的链接关系.
首先考虑基于移动元素的单链表排序算法.采用插入排序方法,在这里也是每次拿一个未排序元素,在已排序序列中找到正确
位置后插入.但是,由于处理的是单链表,为了有效操作,算法中只能按下一个的方向检查和处理表元素
算法工作中,扫描指针crt指向当前考虑的结点(假设这里的表元素为x),在一个大循环中每次处理一个表元素并前进一步.对
一个元素的处理分两步完成:第一步从头开始扫过小于或等于x的元素,直至确定了已排序段里第一个大于x的表元素位置;第
二步是做一系列"倒换",把x放入正确位置,并将其他表元素后移
现在考虑通过调整链接的方式实现插入排序.这种方法的操作过程比较好理解,就是一个取下链表结点,将其插入一段元素递增
的结点链中的正确位置
如果被处理的表为空或只包含一个元素,它自然是排序的,工作完成.表更长时就需要处理.函数里用rem记录除第一个元素之外
的结点段,然后通过循环把这些结点逐一插入_head关联的排序段
函数的内层循环在排序段查找rem结点的插入位置.这里用了两个扫描指针p和q,他们亦步亦趋地前进,直到p所指结点地元素
更大或已到排序段尾,这是结点rem应该插入q和p之间.随后地条件语句分别处理表头插入和一般情况插入,最后连接好排序
段并将rem推进一步.大循环结束时全部结点都插入排序段,工作完成

不同链表地简单总结
讨论时间复杂度时用地n均指表的长度
# 基本单链表包含一系列结点,通过一个方向的链接构造起来.它支持高效的(O(1)的)前端(首端)插入和删除操作,定位操作或尾端操作都需要O(n)时间
# 增加了尾结点引用域的单链表可用很好地支持首端/尾端插入和首端弹出元素,他们都是O(1)时间复杂度的操作,但不能支持高效的尾端删除
# 循环单链表也能支持高效的表首端/尾端插入和首端弹出元素.在这种表上扫描,需要特别注意结束判断问题
# 双链表中每个结点都有两个方向的链接,因此可用高效地找到前后结点.如果有尾结点引用,两端插入和删除操作都能在O(1)时间完成.循环双链表地性质类似
# 对于单链表,遍历和数据检索操作都只能从表头开始,需要O(n)时间.对于双链表,这些操作可用从表头或表尾开始,复杂度不变.与它们对应地两种循环链表,遍历和检索可用从表中任何一个地方开始,但要注意结束条件
链接表有一些重要优点,分析如下:
# 表结构是通过一些链接起来地结点形成地,结点(及其中表元素)之间地顺序由链接关系决定,链接可以修改,因此表地结构很容易调整和修改
# 不需要修改结点里地数据元素或移动他们,只通过修改结点之间地链接,就能灵活地修改表的结构和数据排列方式.例如,加入/
删除一个或多个元素,翻转整个表,重排表中元素顺序,将一个表根据需要划分尾两个表或多个表,等等
# 整个表由一些小的存储块构成,比较容易安排和管理.用Python编写程序时,这些问题由解释器负责,程序员不必处理,但了解情况也很重要
链接表也有一些明显的缺点,主要是一些操作的代价比较大:
# 定位访问(基于位置找到元素)需要线性时间,这是与顺序表相比最大劣势
# 简单单链表上的尾端操作需要线性时间.增加一个尾指针,可以将尾端插入变成常量时间操作,但仍不能有效实现尾端删除.
双链表通过在每个结点里增加第二个链接,可以实现两端的高效插入和删除
# 要找到当前元素的前移元素,必须从头开始扫描表结点.这种操作应尽量避免.双链表可以解决这个问题,但每个结点要付出更多存储代价
# 为存储一个表元素,需要多用一个链接域,这是实现链接表的存储代价.双链表可以提高链表操作的灵活性,但需要增加两个链接域

表的应用
Josephus问题和基于"数组"概念的解法
Josephus问题:假设有n个人围坐一圈,现在要求从第k个人开始报数,报到第m个数的人退出.然后从下一个人开始继续报数并按
同样规则退出,直至所有人退出.要求按顺序输出各出列人的编号
第一种解决方法:基于Python的list和固定大小的"数组"概念,在这里把list看作元素个数固定的对象,只修改元素的值,不
改变表的结构(不用加入或删除元素的操作).这相当于摆了一圈n把椅子,人可以走但椅子在那里且位置不变.基于这种设计
可以有多种实现方法.下面的方法是给每个人赋予一个编号,没有人的情况用o表示,各list的元素记录这些编号.

基于顺序表的解:把保存人员编号的list按表的方式处理,一旦确定了应该退出的人,就将表示其编号的表元素从表中删除
用num表示表的长度,每退出一人,表的长度num减一,至表长度为0时计算工作结束
下标更新可以用i=(i+m-1)%num统一描述

基于循环单链表的解:从形式上看,循环单链表可以很直观地表示围坐一圈地人,顺序数人头可以自然地反映为在循环表中沿着
next链扫描,一个人退出可以用删除相应结点地操作模拟.
1)建立包含指定个数(和内容)地结点地循环单链表,这件事可以通过从空表出发,在尾部逐个加入元素地方式完成
2)循环计数,找到并删除应该退出地结点
基于循环单链表类派生出一个专门的类用其初始化方法完成全部工作
把计数过程看作人圈的转动(结点环的转动).定义了新方法turn,将循环表对象的rear指针沿着next方向移动m步(相当于结点环转动)
这个类的初始化函数首先调用基类LCList的初始化函数建立一个空表,然后通过一个循环建立包含n个结点和相应数据的初始
循环表.最后的循环反复调用turn方法,找到并逐个弹出结点,输出结点里保存的编号
虽然这里用了一个类作为基础,其使用方式却与调用一个函数类似,建立这个类的对象就是完成一次计算,所创建对象本身并不重要.

本章总结
线性表的概念,其基本运算和抽象数据类型,以及两种实现技术(顺序表和链接表实现).线性表是一种比较简单的数据结构,
是n个数据元素的有限序列,各元素在表中有特定的排列位置和前后顺序关系.
构造pnext表:分析
# 模式串移动之后,作为下一个用于匹配的字符的新位置,其前缀子串应该与匹配失败的字符之间同样长度的子串相同
# 如果匹配在模式串的位置i失败时,而位置i的前缀子串中满足上述条件的位置不止移除,那么只能做最短的移动,将模式串
移到最近的哪个满足上述条件的位置,以保证不遗漏可能的匹配