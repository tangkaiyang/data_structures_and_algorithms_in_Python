计算机按程序的指示完成计算,而非程序完成计算
需求分析:深入分析问题,弄清其方方面面的情况和细节,将问题严格化,最终得到一个比较详尽的尽可能严格表述的问题描述
数据结构:研究数据的组织技术
算法:在良好组织的数据结构上完成计算

一个简单的例子
需求:求出任一非负实数的平方根
计算的有穷性:对任意非负实数x,设法找到一个非负实数y,使得|y*y-x|<e,其中e是事先给定的允许误差
牛顿迭代法:
0.对给定正实数x和允许误差e,令变量y取任意正实数值,如令y=x
1.如果y*y与x足够接近,即|y*y-x|<e,计算结束并把y作为结果
2.取z=(y+x/y)/2
3.将z作为y的新值,回到步骤1
需证明两个断言:
1,对任一正实数x,如果算法结束,它一定能给出x的平方根的近似值;
2,对任意给定的误差e,这个算法一定结束(实际上,这件事还与误差e和计算机实数表示精度有关)
牛顿迭代法的推导:中值定理+泰勒多项式

红绿灯设计
数据结构图,图中元素称为定点,连线称为边或弧.相互之间有边的定点称为邻接顶点
以非相邻为条件的最佳顶点分组问题,实际上对应于有名的图最佳着色问题:
把顶点看做区域,把相邻看做两个区域有边界,把不同分组看做相邻顶点以不同颜色着色.
两种最基本的算法设计方法:
# 枚举和选择(选优):根据问题,设法枚举出所有可能情况,首先筛选出问题的解,而后从中得到最优解
# 贪心法:根据当时已知的局部信息,完成尽可能多的工作.这样做通常可以得到正确的解,但可能并非最优.对于一个复杂的问题,
全面考虑的工作代价可能太高,为得到实际可用的算法,常常需要在最优方面做出妥协

三个基本概念
# 问题
# 问题实例
# 算法

算法的性质:一个算法是对一种计算过程的一个严格描述,
# 有穷性(算法描述的有穷性):一个算法的描述应该由有限多条指令或语句构成.也就是说,算法必须能用有限长的描述说清楚
# 能行性:算法中指令(语句)的含义严格而且简单明确,所描述的操作(计算)过程可以完全机械地进行
# 确定性:作用于所求解问题的给定输入(以某种描述形式给出的要处理问题的具体实例),根据算法的描述将产生出唯一的确定的一个
动作序列.使用算法就是把问题实例(的表示)送给他,通过确定性的操作序列,最终得到相应的解
# 终止性(行为的有穷性):对问题的任何实例,算法产生的动作序列都是有穷的,它或者终止并给出该问题实例的解;或者终止并指出给定的输入无解
# 输入/输出:有明确定义的输入和输出

算法设计模式,常见模式:
# 枚举法:根据具体问题枚举出各种可能,从中选出有用信息或者问题的解.这种方法利用计算机的速度优势,在解决简单问题时十分有效
# 贪心法:如前所述,根据问题的信息尽可能做出部分的解,并基于部分解逐步扩充得到完整的解.在解决复杂问题时,这种做法未必能得到最好的解
# 分治法:把复杂问题分解成相对简单的子问题,分别求解,最后通过组合起子问题的解的方式得到原问题的解
# 回溯法(搜索法):专指通过搜索的方式求解.如果问题很复杂,没有清晰的求解路径,可能就需要分步骤进行,而每一步骤又可能有多种选择.
在这种情况下,只能采用试探的方式,根据实际情况选择一个可能方向.当后面的求解步骤无法继续时,就需要退回到前面的步骤,
另行选择求解路径,这种动作称为回溯
# 动态规划法:在一些复杂情况下,问题求解很难直截了当地进行,因此需要在前面的步骤中积累信息,在后续步骤中根据已知信息,动态选择已知的最好求解路径(同时可能进一步积累信息).这种算法模式被称为动态规划
# 分支界限法:可以看作搜索方法的一种改良形式.如果在搜索过程中可以得到一些信息,确定某些可能的选择实际上并不可用,
就可以及早将其删除,以缩小可能的求解空间,加速问题求解过程

一个算法的实施必定蕴涵了一定量的时间和空间开销.算法分析的主要任务就是弄清算法的消耗

抽象研究算法性质所作的假设:
# 所用的计算设备中为数据存储准备了一组基本单元,每个单元只能保存固定的一点有限数据.在考虑算法的时间性质时,将以此作为空间的单元
# 机器能执行一些基本操作,计算中的一次操作消耗一个单位的时间
算法的计算(时间和空间)开销定义为问题的实例规模的函数

"大O记法":对于单调的整数函数f,如果存在一个整数函数g和实常数c>0,是的对应充分大的n总有f(n)<=c.g(n),就说
函数g是f的一个渐近函数(忽略常量因子),记为f(n)=O(g(n)).
易见,f(n)=O(g(n))说明在趋向无穷的极限意义下,函数f的增长速度受到函数g的约束
把上述描述方式应用于算法的代价问题.假设存在函数g,使得算法A处理规模为n的问题实例所用的时间T(n)=O(g(n)),
则称O(g(n))为算法A的渐近时间复杂度,简称时间复杂度.
算法的空间复杂度S(n)的定义于此类似
常用的渐近复杂度函数:
O(1)常量复杂度, O(log n)对数复杂度, O(n)线性复杂度, O(n log n), O(n*n)平方复杂度, O(n*n*n), O(2^n)指数复杂度
在考虑量级时对数的底并不是主要因素(可能差一个常量因子),因此可以忽略.
一个算法的时间复杂度为O(n),也常说这个算法是O(n)时间的算法,或者说这个算法需要O(n)时间等
如果有T(n)=O(g(n))(或者S(n)=O(g(n))),函数g(n)是算法的实际时间开销的一个上界,并不表示实际开销真正具有与g(n)同样的增长速度(只说明增长速度不超过g(n))

1.3.3 算法分析:目的是推导出算法的复杂度,其中最主要的技术是构造和求解递归方程
高斯消元法:通过逐行消元,把原矩阵变换为一个上三角线矩阵,最后乘其所有对角线元素,就得到矩阵行列式的值

1.3.4 Python程序的计算代价(复杂度)
时间开销:在考虑Python程序的时间开销时,需注意:Python程序中的很多基本操作不是常量时间的
下面是一些基本情况:
# 基本算术运算是常量时间操作,逻辑运算是常量时间运算
# 组合对象的操作有些是常量时间的,有些不是,例如:
# # 复制和切片操作通常需要线性时间(与长度有关,是O(n)时间操作)
# # list和tuple的元素访问和元素赋值,是常量时间的
# # dict操作的情况比较复杂
  使用组合对象的程序,需要特别考虑其中操作的复杂度
# 字符串也应该看做组合对象,其许多操作不是常量时间的
# 创建对象也需要付出空间和时间,空间和时间代价都与对象大小有关.对于组合对象,这里可能有需要构造的一个个元素,
元素有大小问题,整体看还有元素个数问题.通常应该看做线性时间和线性空间操作(以元素个数作为规模)

一些Python结构和操作的效率问题
# 构造新结构,如构造新的list,set等.构造新的空结构(空表,空集合等)是常量时间操作,而构造一个包含n个元素的结构,
则至少需要O(n)时间.统计说明,分配长度为n个元素的存储块的时间代价为O(n)
# 一些list操作的效率:表元素访问和元素修改是常量时间操作,但一般的加入/删除元素操作(即使只加入一个元素)都是O(n)时间操作
# 字典dict操作的效率:主要操作是加入新的关键码-值对和基于关键码查找关联值.他们的最坏情况复杂度是O(n),但平均
复杂度是O(1).这是非常有趣的现象,也就是说,一般而言字典操作的效率很高,但偶然也会出现效率低的情况
上面的复杂度中的n都是有关结构中的元素个数.
有些操作的效率高.例如,在表的最后加入和删除元素的操作效率高,在其他地方加入和删除元素的效率低,应该优先选用前者

空间开销
在程序中使用任何类型的对象,都需要付出空间的代价.建立一个表或者元组,至少要占用元素个数那么多空间.如果一个表的
元素个数与问题规模线性相关,建立它的空间付出至少为O(n)(如果元素也是新创建的,还需考虑元素本身的存储开销)
相对而言,表和元组是比较简单的数据结构.集合和字典需要支持快速查询等操作,其结构更加复杂.
包含n个元素的集合或字典,至少需要占用O(n)的存储空间
需要特别注意的两个问题:
1)Python的各种组合数据对象都没有预设的最大元素个数.在实际使用中,这些结构能根据元素个数的增长自动扩充存储空间.
从空间占用的角度看,其实际开销在存续期间可能变大,但通常不会自动缩小(即使后来元素变得很少了).
举个例子,假设程序里建了一个表,而后不断加入元素导致表变得很大,而后又不断删除元素,后来表中元素变得很少,但占用的存储空间并不减少
2)还应该注意Python自动存储管理系统的影响.举个例子:如果在程序建立了一个表,此后一直将其作为某个全局变量的值,
这个对象就会始终存在并占用存储空间.如果将其作为某个函数里局部变量的值,或者虽然作为全局变量的值,但后来通过赋值
将其抛弃,这个表对象就可以被回收.

程序实现和效率陷阱
算法的实现(程序)的时间开销与原算法的时间复杂度之间的关系.

1.4 数据结构
从程序输入和输出的角度看,用计算机解决问题,可以看做实现某种信息表示形式的转换.
为了能用计算机处理与问题有关的信息,就必须采用某种方式表示他,并将相应表示送入计算机.
信息通过表示就变成了(计算机处理的)数据.与问题有关的信息可能很复杂,不仅是可能数量庞大,而且信息之间可能存在错综复杂的相互联系.
为了能在计算机中有效处理,必须以适当的形式把蕴涵了这些信息的数据组织好.需要处理的信息的情况越复杂,处理过程(计算
过程)越复杂,数据的良好组织就越重要

1.4.1 数据机构及其分类
信息,数据和数据结构
数据(data)就是指计算机(程序)能够处理的符号形式的总和,或者是经过了编码的信息(信息的编码表示)
数据元素(data element)值最基本的数据单位.
在计算机硬件层面,所有被存储和处理的数据最终都编码为二进制代码形式.一切数据最终都表示为二进制位的序列,最基本的数据
单位就是一个二进制位.但是再计算机应用的各个层面上,数据可能具有更加丰富多彩的表现,这时说一个数据元素就是指
再当前的上下文中作为整体保存和处理的一个数据单元.
数据结构(data structure)研究数据之间的关联和组合的形式,总结其中的规律性,发掘特别值得注意的有用结构,研究这些
结构的性质,进而研究如何再计算机里实现这些有用的数据结构,以支持相应组合数据的高效使用,支持处理他们的高效算法.
在考虑数据结构时,其数据元素作为原子性的单元,可以任意简单或复杂,没有任何限制

抽象定义和重要类别
抽象定义:D=(E, R),E是数据结构D的元素集合,R是D的元素之间的某种关系
典型数据结构:
# 集合结构:其数据元素之间没有需要关注的明确关系
# 序列结构:其数据元素之间有一种明确的先后关系(顺序关系),也称线性结构
# 层次结构:其数据元素分属于一些不同的层次,一个上层元素可以关联着一个或者多个下层元素,关系R形成一种明确的层次性,
只从上层到下层(通常也允许跨层次).层次关系又可分为许多简单或复杂的子类别
# 树形结构:层次结构中最简单的一种关系是树形关系,其特点是在一个树形结构中只有一个最上层数据元素,称为根,
其余元素都是根的直接或简介关联的下层元素.除了根元素之外的每个元素,都有且仅有一个上层元素与之关联.
树形数据结构简称为树,相应的复杂数据对象称为树形对象.
# 图结构:数据元素之间可以有任意复杂的相互联系.数学领域中的图概念是这类复杂结构的抽象,因此人们把这样的结构称为
图结构,把这样的复杂对象称为图对象.
实际上,可以认为图结构包含了前面几类结构,把那些结构看作图的受限形式.由于其中元素之间的关系受限,可能存在一些有意义的特殊性质.
结构性和功能性的数据结构:
结构性的数据结构:这些数据结构都对其数据之间的相互关系做出了一些规定,元素之间确实满足某种关系才能被称为线性结构
或树结构等,这些数据结构的最重要特征就是他们的结构
功能性的数据结构:他们并没有对其元素的相互关系提出任何结构性的规定,而是要求实现某种计算中非常有用的功能.
最为可以包含一批数据元素的结构,最基本的要求就是支持元素的存储和使用(使用也常称为元素访问).这个基本要求实际上是
功能性的要求,而非结构性的要求,因为它完全不涉及元素如何存储,元素之间如何关联.支持元素存储和访问的数据结构被
称为容器.
功能性数据结构包括栈,队列,优先队列,字典等.这些结构都支持以某一套方法存储和访问元素(包括删除元素),但不同结构提供了
不同的元素访问特性,其具体操作表现出各自的特性,这些特性在抽象算法和实际程序里都非常重要.
由于只有功能要求,这类数据结构可以采用任何技术实现.实际中人们通常首先把这类数据结构映射到某种结构性的数据结构,
而后采用相应的实现技术.

1.4.2 计算机内存对象表示
内存单元和地址
计算中(程序中)直接使用的数据保存在计算机的内存储器(简称内存).内存是CPU可以直接访问的数据存储设备.与之对应的是
外存储器,简称外存,如磁盘,光盘,磁带等.保存在外村中的数据必须先装入内存,而后CPU才能使用他们.
内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.具体单元大小可能因计算机的不同
而有所不同.在目前最常见的计算机中,一个单元可以保存一个字节(8位二进制代码)的数据.因此存放在一个整数或者浮点数,
需要连续的几个单元.例如标准的浮点数需要8个单元.
内存单元具有唯一编号,称为单元地址,简称地址.单元地址从0开始连续排列,全部可用地址为从0开始的一个连续的正整数区间,
在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个单元,必须先掌握其地址.
在许多计算机中,一次内存访问可用存取若干个单元的内容.例如目前常见的64位计算机,一次可以存取8个字节的数据,也就是说一次
操作访问8个单元的内容.基于地址访问内存单元是一个O(1)操作,与单元的位置或整个内存的大小无关,这是分析与数据结构
有关的算法时的一个基本假设.在高级语言层面讨论和分析数据结构问题时,人们通常不关心具体的单元大小或地址范围,
只假定所考虑数据保存在内存的某处,而且假定这种访问时常量时间的.
对象存储和管理
在程序运行中,可能需要构造,使用,处理各种各样的对象,他们都将在计算机的线性结构的内存里安排位置.为了表示
程序中的一个对象,需要根据情况,在当时空闲的内存中确定一块或几块区域(内存区域指地址连续排列的一个或一些内存单元)
,把该对象的数据存入其中.在Python程序运行中,建立对象时需要安排存储,还有许多与对象存储和使用有关的管理工作.
解释器的一个专门子系统(称为存储管理系统)负责这些工作.这一工作时自动进行的,编写程序的人不必关心.另外,
当一个对象不再有用时,存储管理系统也会设法回收其占用的存储,以便在将来用于存储其他对象.
一个程序在运行中将不断建立一些对象并使用他们.建立的每个对象都有一个确定的唯一标识,用于识别和使用这个对象.
在一个对象的存续期间,其标识保持不变,这也是一个基本原则.
例如,Python标准函数id取得对象的标识,内置操作is和is not通过比较标识的方式判断是否为同一个对象.在具体系统里用做什么作为
对象标识,是系统设计者的考虑和选择,最简单的方式就是直接使用对象的存储位置(内存地址)
对象的访问
index(下标), p(偏移量)
对象关联的表示
基本类型数据(如字符,整数和浮点数)的内存表示方式由编程语言和计算机硬件确定,一项数据占据确定数目的几个连续单元,
例如一个浮点数通常占用连续的8个字节单元.
复杂数据对象(数据结构)包含了一批元素(数据成员),这些元素本身也是数据对象,可能是基本数据,也可能是具有比较简单
内部结构的复杂对象,元素间通常又某些关系.表示这样的复杂结构:数据元素和元素之间的联系.
计算机内存里表示数据元素之间的联系,只有两种基本技术:
1)利用数据元素的存储位置隐式表示.由于内存是单元的线性序列,知道了前一个元素的位置及其大小(存储占用量),就能
确定下一个元素的位置.如果存储的是一系列大小相同的元素,就可用利用前面公式直接算出序列中任何一个元素的位置.
显然,序列数据结构中元素的线性关系可用用这种方式表示
2)把数据元素之间关系也看作一种数据,显示地保存在内存中.用这种方式可用表示数据元素之间任意复杂地关系,隐藏这种技术地功能更强大.
第一种称为元素的顺序表示:
第二种:二元结构里记录引用信息(记录两个字符串对象的标识),对象的链接表示技术,链接结构

1.4.3 Python对象和数据结构
Python变量和对象
高级语言里的变量(全局变量,函数的局部变量和参数)是内存及其地址的抽象.
给变量约束一个对象,就是把该对象的标识(内存地址)存入该变量
Python变量的值都是对象,可用是基本整数,浮点型等类型的对象,也可以是组合类型的对象,如list等.程序中建立和使用
的各种复杂对象,包括Python函数等,都基于独立的存储块实现,通过链接相互关联.程序里的名字(变量,参数,函数名等)关联这作为
其值的对象,这种关联可用用赋值操作改变
Python语言中变量的这种实现方式称为变量的引用语义,在变量里保存值(对象)的引用.
有些语言直接把变量的值保存在变量的存储区里,称为值语义.

两方面的问题:
一.人们也经常需要自己设计一些数据结构,这时需要考虑实现的效率问题,需要对构造的数据结构的基本技术有所了解.
二.使用语言本身提供的各种高级结构,例如Python的list和dict等,也需要对这些结构的基本性质,以及实现他们的基本
原理有准确理解,才能正确有效地使用他们.

Python的几个标准数据类型:
list(表),tuple(元组),dict(字典)