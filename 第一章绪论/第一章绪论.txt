计算机按程序的指示完成计算,而非程序完成计算
需求分析:深入分析问题,弄清其方方面面的情况和细节,将问题严格化,最终得到一个比较详尽的尽可能严格表述的问题描述
数据结构:研究数据的组织技术
算法:在良好组织的数据结构上完成计算

一个简单的例子
需求:求出任一非负实数的平方根
计算的有穷性:对任意非负实数x,设法找到一个非负实数y,使得|y*y-x|<e,其中e是事先给定的允许误差
牛顿迭代法:
0.对给定正实数x和允许误差e,令变量y取任意正实数值,如令y=x
1.如果y*y与x足够接近,即|y*y-x|<e,计算结束并把y作为结果
2.取z=(y+x/y)/2
3.将z作为y的新值,回到步骤1
需证明两个断言:
1,对任一正实数x,如果算法结束,它一定能给出x的平方根的近似值;
2,对任意给定的误差e,这个算法一定结束(实际上,这件事还与误差e和计算机实数表示精度有关)
牛顿迭代法的推导:中值定理+泰勒多项式

红绿灯设计
数据结构图,图中元素称为定点,连线称为边或弧.相互之间有边的定点称为邻接顶点
以非相邻为条件的最佳顶点分组问题,实际上对应于有名的图最佳着色问题:
把顶点看做区域,把相邻看做两个区域有边界,把不同分组看做相邻顶点以不同颜色着色.
两种最基本的算法设计方法:
# 枚举和选择(选优):根据问题,设法枚举出所有可能情况,首先筛选出问题的解,而后从中得到最优解
# 贪心法:根据当时已知的局部信息,完成尽可能多的工作.这样做通常可以得到正确的解,但可能并非最优.对于一个复杂的问题,
全面考虑的工作代价可能太高,为得到实际可用的算法,常常需要在最优方面做出妥协

三个基本概念
# 问题
# 问题实例
# 算法

算法的性质:一个算法是对一种计算过程的一个严格描述,
# 有穷性(算法描述的有穷性):一个算法的描述应该由有限多条指令或语句构成.也就是说,算法必须能用有限长的描述说清楚
# 能行性:算法中指令(语句)的含义严格而且简单明确,所描述的操作(计算)过程可以完全机械地进行
# 确定性:作用于所求解问题的给定输入(以某种描述形式给出的要处理问题的具体实例),根据算法的描述将产生出唯一的确定的一个
动作序列.使用算法就是把问题实例(的表示)送给他,通过确定性的操作序列,最终得到相应的解
# 终止性(行为的有穷性):对问题的任何实例,算法产生的动作序列都是有穷的,它或者终止并给出该问题实例的解;或者终止并指出给定的输入无解
# 输入/输出:有明确定义的输入和输出

算法设计模式,常见模式:
# 枚举法:根据具体问题枚举出各种可能,从中选出有用信息或者问题的解.这种方法利用计算机的速度优势,在解决简单问题时十分有效
# 贪心法:如前所述,根据问题的信息尽可能做出部分的解,并基于部分解逐步扩充得到完整的解.在解决复杂问题时,这种做法未必能得到最好的解
# 分治法:把复杂问题分解成相对简单的子问题,分别求解,最后通过组合起子问题的解的方式得到原问题的解
# 回溯法(搜索法):专指通过搜索的方式求解.如果问题很复杂,没有清晰的求解路径,可能就需要分步骤进行,而每一步骤又可能有多种选择.
在这种情况下,只能采用试探的方式,根据实际情况选择一个可能方向.当后面的求解步骤无法继续时,就需要退回到前面的步骤,
另行选择求解路径,这种动作称为回溯
# 动态规划法:在一些复杂情况下,问题求解很难直截了当地进行,因此需要在前面的步骤中积累信息,在后续步骤中根据已知信息,动态选择已知的最好求解路径(同时可能进一步积累信息).这种算法模式被称为动态规划
# 分支界限法:可以看作搜索方法的一种改良形式.如果在搜索过程中可以得到一些信息,确定某些可能的选择实际上并不可用,
就可以及早将其删除,以缩小可能的求解空间,加速问题求解过程

一个算法的实施必定蕴涵了一定量的时间和空间开销.算法分析的主要任务就是弄清算法的消耗

抽象研究算法性质所作的假设:
# 所用的计算设备中为数据存储准备了一组基本单元,每个单元只能保存固定的一点有限数据.在考虑算法的时间性质时,将以此作为空间的单元
# 机器能执行一些基本操作,计算中的一次操作消耗一个单位的时间
算法的计算(时间和空间)开销定义为问题的实例规模的函数

"大O记法":对于单调的整数函数f,如果存在一个整数函数g和实常数c>0,是的对应充分大的n总有f(n)<=c.g(n),就说
函数g是f的一个渐近函数(忽略常量因子),记为f(n)=O(g(n)).
易见,f(n)=O(g(n))说明在趋向无穷的极限意义下,函数f的增长速度受到函数g的约束
把上述描述方式应用于算法的代价问题.假设存在函数g,使得算法A处理规模为n的问题实例所用的时间T(n)=O(g(n)),
则称O(g(n))为算法A的渐近时间复杂度,简称时间复杂度.
算法的空间复杂度S(n)的定义于此类似
常用的渐近复杂度函数:
O(1)常量复杂度, O(log n)对数复杂度, O(n)线性复杂度, O(n log n), O(n*n)平方复杂度, O(n*n*n), O(2^n)指数复杂度
在考虑量级时对数的底并不是主要因素(可能差一个常量因子),因此可以忽略.
一个算法的时间复杂度为O(n),也常说这个算法是O(n)时间的算法,或者说这个算法需要O(n)时间等
如果有T(n)=O(g(n))(或者S(n)=O(g(n))),函数g(n)是算法的实际时间开销的一个上界,并不表示实际开销真正具有与g(n)同样的增长速度(只说明增长速度不超过g(n))

1.3.3 算法分析:目的是推导出算法的复杂度,其中最主要的技术是构造和求解递归方程
高斯消元法:通过逐行消元,把原矩阵变换为一个上三角线矩阵,最后乘其所有对角线元素,就得到矩阵行列式的值

1.3.4 Python程序的计算代价(复杂度)
时间开销:在考虑Python程序的时间开销时,需注意:Python程序中的很多基本操作不是常量时间的
下面是一些基本情况:
# 基本算术运算是常量时间操作,逻辑运算是常量时间运算
# 组合对象的操作有些是常量时间的,有些不是,例如:
# # 复制和切片操作通常需要线性时间(与长度有关,是O(n)时间操作)
# # list和tuple的元素访问和元素赋值,是常量时间的
# # dict操作的情况比较复杂
  使用组合对象的程序,需要特别考虑其中操作的复杂度
# 字符串也应该看做组合对象,其许多操作不是常量时间的
# 创建对象也需要付出空间和时间,空间和时间代价都与对象大小有关.对于组合对象,这里可能有需要构造的一个个元素,
元素有大小问题,整体看还有元素个数问题.通常应该看做线性时间和线性空间操作(以元素个数作为规模)

一些Python结构和操作的效率问题
# 构造新结构,如构造新的list,set等.构造新的空结构(空表,空集合等)是常量时间操作,而构造一个包含n个元素的结构,
则至少需要O(n)时间.统计说明,分配长度为n个元素的存储块的时间代价为O(n)
# 一些list操作的效率:表元素访问和元素修改是常量时间操作,但一般的加入/删除元素操作(即使只加入一个元素)都是O(n)时间操作
# 字典dict操作的效率:主要操作是加入新的关键码-值对和基于关键码查找关联值.他们的最坏情况复杂度是O(n),但平均
复杂度是O(1).这是非常有趣的现象,也就是说,一般而言字典操作的效率很高,但偶然也会出现效率低的情况
上面的复杂度中的n都是有关结构中的元素个数.
有些操作的效率高.例如,在表的最后加入和删除元素的操作效率高,在其他地方加入和删除元素的效率低,应该优先选用前者

空间开销
在程序中使用任何类型的对象,都需要付出空间的代价.建立一个表或者元组,至少要占用元素个数那么多空间.如果一个表的
元素个数与问题规模线性相关,建立它的空间付出至少为O(n)(如果元素也是新创建的,还需考虑元素本身的存储开销)
相对而言,表和元组是比较简单的数据结构.集合和字典需要支持快速查询等操作,其结构更加复杂.
包含n个元素的集合或字典,至少需要占用O(n)的存储空间
需要特别注意的两个问题:
1)Python的各种组合数据对象都没有预设的最大元素个数.在实际使用中,这些结构能根据元素个数的增长自动扩充存储空间.
从空间占用的角度看,其实际开销在存续期间可能变大,但通常不会自动缩小(即使后来元素变得很少了).
举个例子,假设程序里建了一个表,而后不断加入元素导致表变得很大,而后又不断删除元素,后来表中元素变得很少,但占用的存储空间并不减少
2)还应该注意Python自动存储管理系统的影响.举个例子:如果在程序建立了一个表,此后一直将其作为某个全局变量的值,
这个对象就会始终存在并占用存储空间.如果将其作为某个函数里局部变量的值,或者虽然作为全局变量的值,但后来通过赋值
将其抛弃,这个表对象就可以被回收.

程序实现和效率陷阱
算法的实现(程序)的时间开销与原算法的时间复杂度之间的关系.

1.4 数据结构
从程序输入和输出的角度看,用计算机解决问题,可以看做实现某种信息表示形式的转换.
为了能用计算机处理与问题有关的信息,就必须采用某种方式表示他,并将相应表示送入计算机.
信息通过表示就变成了(计算机处理的)数据.与问题有关的信息可能很复杂,不仅是可能数量庞大,而且信息之间可能存在错综复杂的相互联系.
为了能在计算机中有效处理,必须以适当的形式把蕴涵了这些信息的数据组织好.需要处理的信息的情况越复杂,处理过程(计算
过程)越复杂,数据的良好组织就越重要

1.4.1 数据机构及其分类
信息,数据和数据结构
数据(data)就是指计算机(程序)能够处理的符号形式的总和,或者是经过了编码的信息(信息的编码表示)
数据元素(data element)值最基本的数据单位.
在计算机硬件层面,所有被存储和处理的数据最终都编码为二进制代码形式.一切数据最终都表示为